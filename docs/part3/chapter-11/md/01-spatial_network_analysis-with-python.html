
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Spatial network analysis</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/pythongis.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom-toggle-button.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script>let toggleHintShow = 'Show the solution';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/pythongis-logo.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part I - Python essentials
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part1/chapter-01/index.html">
   1: Getting started
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/00-motivation.html">
     Motivation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/01-computers-and-programs.html">
     Computers and programs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/02-why-python.html">
     Why Python?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/03-writing-and-running-python-code.html">
     Writing and running Python code
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/04-using-jupyterlab.html">
     Using JupyterLab for writing code
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/05-installation.html">
     Installing Python and adding libraries
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part1/chapter-02/index.html">
   2: Basic programming concepts
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/00-python-basics.html">
     Basic elements of Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/01-for-loops.html">
     for loops
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/02-conditional-statements.html">
     Conditional statements
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/03-functions.html">
     Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/04-writing-scripts.html">
     Writing script files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/05-modules.html">
     Loading and using modules
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/06-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part1/chapter-03/index.html">
   3: Introduction to data analysis with Python
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-03/nb/00-pandas-basics.html">
     Getting started with data analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-03/nb/01-data-manipulation.html">
     Common tabular operations in pandas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-03/nb/02-data-analysis.html">
     Data wrangling, grouping and aggregation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-03/nb/03-temporal-data.html">
     Working with temporal data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-03/nb/04-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part1/chapter-04/index.html">
   4: Introduction to data visualization
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-04/nb/00-plotting-in-python.html">
     Plotting in Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-04/nb/01-basic-plotting.html">
     Plotting with pandas and matplotlib
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-04/nb/02-subplots.html">
     Creating subplots
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-04/nb/03-plot-formatting.html">
     Effective plot design: line plots
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-04/nb/04-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part II - Introduction to GIS with Python
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part2/chapter-05/index.html">
   5: Getting started
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-05/nb/00-motivation-to-use-python-for-gis.html">
     Motivation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-05/nb/01-introduction-to-geographic-data-in-python.html">
     Introduction to geographic data in Python
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part2/chapter-06/index.html">
   6: Vector data processing
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-06/nb/00-introduction-to-geopandas.html">
     Introduction to spatial data analysis with geopandas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-06/nb/01-data-io.html">
     Data in/out: Preparing GeoDataFrames from spatial data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-06/nb/02-coordinate-reference-system.html">
     Coordinate Reference Systems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-06/nb/03-geometric-manipulation.html">
     Geometric data manipulations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-06/nb/04-operations-between-multiple-datasets.html">
     Operations between multiple datasets
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-06/nb/05-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part2/chapter-07/index.html">
   7: Raster data processing
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-07/nb/01-reading-raster.html">
     Reading raster files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-07/nb/plotting-raster.html">
     Visualizing raster layers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-07/nb/clipping-raster.html">
     Masking / clipping raster
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-07/nb/raster-map-algebra.html">
     Raster map algebra
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-07/nb/raster-mosaic.html">
     Creating a raster mosaic
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-07/nb/zonal-statistics.html">
     Zonal statistics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-07/nb/read-cogs.html">
     Read Cloud Optimized Geotiffs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-07/nb/exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part2/chapter-08/index.html">
   8: Geographic data visualization
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-08/nb/00-introduction-to-geographic-visualization.html">
     Introduction to geographic visualization
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-08/nb/01-static-maps.html">
     Static maps
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-08/nb/02-interactive-maps.html">
     Interactive maps
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-08/nb/03-map-design-principles-and-colors.html">
     Designing maps
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-08/nb/04-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part2/chapter-09/index.html">
   9: Using online geographic data sources
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-09/nb/00-retrieving-osm-data.html">
     Retrieving OpenStreetMap data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-09/nb/01-retrieving-data-from-wfs.html">
     Retrieving data from Web Feature Service (WFS)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-09/nb/02-retrieving-data-from-wcs.html">
     Retrieving data from Web Coverage Service (WCS)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-09/nb/03-read-data-from-spatial-databases.html">
     Reading data from spatial databases
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part2/chapter-09/nb/04-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part III - Case studies
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../chapter-10/index.html">
   10: Spatial interpolation
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-10/nb/00-introduction-to-spatial-interpolation.html">
     Introduction to spatial interpolation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-10/nb/01-inverse-distance-weighting.html">
     Inverse Distance Weighting interpolation with Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-10/nb/02-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../index.html">
   11: Spatial network analysis
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../nb/00-introduction-to-spatial-network-analysis.html">
     Introduction to spatial network analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../nb/02-multimodal-spatial-accessibility-modelling.html">
     Multimodal spatial accessibility analysis with Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../nb/03-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../chapter-12/index.html">
   12: Terrain analysis
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-12/nb/00-introduction-to-terrain-analysis.html">
     Introduction to terrain analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-12/nb/01-interpreting-topographic-features.html">
     Interpreting topographic features from raster data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-12/nb/02-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../chapter-13/index.html">
   13: Conclusions
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Back matter
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../back-matter/nb/acknowledgements.html">
   Acknowledgements
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../back-matter/appendices.html">
   Appendices
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-1.html">
     Version control with git
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-2.html">
     Collaborative coding with GitHub
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-3.html">
     Using Python script files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-4.html">
     Testing and debugging your code
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-5.html">
     Solutions to questions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-6.html">
     Exercise solutions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../back-matter/nb/glossary.html">
   Glossary
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../back-matter/nb/references.html">
   References
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../authors.html">
   About the authors
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Datasets
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../data/index.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../data/noaa-data.html">
   NOAA Weather data
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/Python-GIS-book/site/edit/master/part3/chapter-11/md/01-spatial_network_analysis-with-python.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>

</a>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../../../_sources/part3/chapter-11/md/01-spatial_network_analysis-with-python.md.txt"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#typical-workflow-for-routing">
   Typical workflow for routing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#retrieve-data">
     1. Retrieve data
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modify-the-data">
   2. Modify the data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-build-a-directed-graph-from-scratch-see-3b-for-easier-approach">
   3a. Build a directed graph from scratch (see 3b for easier approach)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#b-build-a-directed-graph-with-pyrosm">
   3b. Build a directed graph with pyrosm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#routing-with-networkx">
   4. Routing with NetworkX
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#basic-logic-in-routing">
     Basic logic in routing
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#find-the-optimal-route-between-two-locations">
   Find the optimal route between two locations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#find-the-nearest-nodes">
     Find the nearest nodes
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#find-the-fastest-route-by-distance-time">
     Find the fastest route by distance / time
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#calculate-travel-times-from-one-to-many-locations">
   Calculate travel times from one to many locations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#alternative-approach-ego-graph">
     Alternative approach - Ego graph
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#larger-scale-analysis">
   Larger scale analysis
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Spatial network analysis</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#typical-workflow-for-routing">
   Typical workflow for routing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#retrieve-data">
     1. Retrieve data
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modify-the-data">
   2. Modify the data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-build-a-directed-graph-from-scratch-see-3b-for-easier-approach">
   3a. Build a directed graph from scratch (see 3b for easier approach)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#b-build-a-directed-graph-with-pyrosm">
   3b. Build a directed graph with pyrosm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#routing-with-networkx">
   4. Routing with NetworkX
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#basic-logic-in-routing">
     Basic logic in routing
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#find-the-optimal-route-between-two-locations">
   Find the optimal route between two locations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#find-the-nearest-nodes">
     Find the nearest nodes
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#find-the-fastest-route-by-distance-time">
     Find the fastest route by distance / time
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#calculate-travel-times-from-one-to-many-locations">
   Calculate travel times from one to many locations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#alternative-approach-ego-graph">
     Alternative approach - Ego graph
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#larger-scale-analysis">
   Larger scale analysis
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="spatial-network-analysis">
<h1>Spatial network analysis<a class="headerlink" href="#spatial-network-analysis" title="Permalink to this headline">#</a></h1>
<p>In this section we will focus on a network analysis methods that relate to way-finding. We will learn the basic elements of a <strong>spatial network</strong>. In addition, we will learn how to construct a routable <strong>directed</strong> graph for Networkx and find shortest paths along the given street network based on travel times or distance by car. In addition, we will learn how to calculate travel times from a single source into all nodes in the graph. Finding a shortest path from A to B using a specific street network is a very common spatial analytics problem that has many practical applications.</p>
<p>Python provides easy to use tools for conducting spatial network analysis. One of the easiest ways to start is to use a library called <a class="reference external" href="https://networkx.github.io/documentation/stable/">Networkx</a> which is a Python module that provides a lot tools that can be used to analyze networks on various different ways. It also contains algorithms such as <a class="reference external" href="https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.weighted.single_source_dijkstra.html#networkx.algorithms.shortest_paths.weighted.single_source_dijkstra">Dijkstra’s algorithm</a>
or <a class="reference external" href="https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.astar.astar_path.html#networkx.algorithms.shortest_paths.astar.astar_path">A*</a>
algoritm that are commonly used to find shortest paths along transportation network.</p>
<p>Next, we will learn how to do spatial network analysis in practice.</p>
<section id="typical-workflow-for-routing">
<h2>Typical workflow for routing<a class="headerlink" href="#typical-workflow-for-routing" title="Permalink to this headline">#</a></h2>
<p>If you want to conduct network analysis (in any programming language) there are a few basic steps that typically needs to be done before you can start routing. These steps are:</p>
<ol class="simple">
<li><p><strong>Retrieve data</strong> (such as street network from OSM or Digiroad + possibly transit data if routing with PT).</p></li>
<li><p><strong>Modify the network</strong> by adding/calculating edge weights (such as travel times based on speed limit and length of the road segment).</p></li>
<li><p><strong>Build a routable graph</strong> for the routing tool that you are using (e.g. for NetworkX, igraph or OpenTripPlanner).</p></li>
<li><p><strong>Conduct network analysis</strong> (such as shortest path analysis) with the routing tool of your choice.</p></li>
</ol>
<section id="retrieve-data">
<h3>1. Retrieve data<a class="headerlink" href="#retrieve-data" title="Permalink to this headline">#</a></h3>
<p>As a first step, we need to obtain data for routing. <a class="reference external" href="https://pyrosm.readthedocs.io/en/latest/">Pyrosm</a> library makes it really easy to retrieve routable networks from OpenStreetMap (OSM) with different transport modes (walking, cycling and driving).</p>
<ul class="simple">
<li><p>Let’s first extract OSM data for Helsinki that are walkable. In <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code>, we can use a function called <code class="docutils literal notranslate"><span class="pre">osm.get_network()</span></code> which retrieves data from OpenStreetMap. It is possible to specify what kind of roads should be retrieved from OSM with <code class="docutils literal notranslate"><span class="pre">network_type</span></code> -parameter (supports <code class="docutils literal notranslate"><span class="pre">walking</span></code>, <code class="docutils literal notranslate"><span class="pre">cycling</span></code>, <code class="docutils literal notranslate"><span class="pre">driving</span></code>).</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyrosm</span> <span class="kn">import</span> <span class="n">OSM</span><span class="p">,</span> <span class="n">get_data</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="c1"># We will use test data for Helsinki that comes with pyrosm</span>
<span class="n">osm</span> <span class="o">=</span> <span class="n">OSM</span><span class="p">(</span><span class="n">get_data</span><span class="p">(</span><span class="s2">&quot;helsinki_pbf&quot;</span><span class="p">))</span>

<span class="c1"># Parse roads that can be driven by car</span>
<span class="n">roads</span> <span class="o">=</span> <span class="n">osm</span><span class="o">.</span><span class="n">get_network</span><span class="p">(</span><span class="n">network_type</span><span class="o">=</span><span class="s2">&quot;driving&quot;</span><span class="p">)</span>
<span class="n">roads</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">roads</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Okay, now we have drivable roads as a GeoDataFrame for the city center of Helsinki. If you look at the GeoDataFrame (scroll to the right), we can see that <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> has also calculated us the <code class="docutils literal notranslate"><span class="pre">length</span></code> of each road segment (presented in meters). The geometries are presented here as <code class="docutils literal notranslate"><span class="pre">MultiLineString</span></code> objects. From the map above we can see that the data also includes short pieces of roads that do not lead to anywhere (i.e. they are <em>isolated</em>). This is a typical issue when working with real-world data such as roads. Hence, at some point we need to take care of those in someway (remove them (typical solution), or connect them to other parts of the network).</p>
<p>In OSM, the information about the allowed direction of movement is stored in column <code class="docutils literal notranslate"><span class="pre">oneway</span></code>. Let’s take a look what kind of values we have in that column:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">roads</span><span class="p">[</span><span class="s2">&quot;oneway&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</pre></div>
</div>
<p>As we can see the unique values in that column are <code class="docutils literal notranslate"><span class="pre">&quot;yes&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;no&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>. We can use this information to construct a <code class="docutils literal notranslate"><span class="pre">directed</span></code> graph for routing by car. For walking and cycling, you typically want create a <code class="docutils literal notranslate"><span class="pre">bidirectional</span></code> graph, because the travel is typically allowed in both directions at least in Finland. Notice, that the rules vary by country, e.g. in Copenhagen you have oneway rules also for bikes but typically each road have the possibility to travel both directions (you just need to change the side of the road if you want to make a U-turn). Column <code class="docutils literal notranslate"><span class="pre">maxspeed</span></code> contains information about the speed limit for given road:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">roads</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</pre></div>
</div>
<p>As we can see, there are also <code class="docutils literal notranslate"><span class="pre">None</span></code> values in the data, meaning that the speed limit has not been tagged for some roads. This is typical, and often you need to fill the non existing speed limits yourself. This can be done by taking advantage of the road class that is always present in column <code class="docutils literal notranslate"><span class="pre">highway</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">roads</span><span class="p">[</span><span class="s2">&quot;highway&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</pre></div>
</div>
<p>Based on these values, we can make assumptions that e.g. <code class="docutils literal notranslate"><span class="pre">residential</span></code> roads in Helsinki have a speed limit of 30 kmph. Hence, this information can be used to fill the missing values in <code class="docutils literal notranslate"><span class="pre">maxspeed</span></code>. As we can see, the current version of the <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> tool seem to have a bug because some non-drivable roads were also leaked to our network (e.g. <code class="docutils literal notranslate"><span class="pre">footway</span></code>, <code class="docutils literal notranslate"><span class="pre">cycleway</span></code>). If you notice these kind of issues with any of the libraries that you use, please notify the developers by raising an Issue in GitHub. This way, you can help improving the software. For this given problem, an <a class="reference external" href="https://github.com/HTenkanen/pyrosm/issues/108">issue has already been raised</a> so you don’t need to do it again (it’s always good to check if a related issue exists in GitHub before adding a new one).</p>
<p>Okay, but how can we make a routable graph out of this data of ours? Let’s remind us about the basic elements of a graph that we went through in the lecture slides:</p>
<p><img alt="Basic elements of a graph" src="../../../_images/graph_elements.png" /></p>
<p>So to be able to create a graph we need to have <strong>nodes</strong> and <strong>edges</strong>. Now we have a GeoDataFrame of edges, but where are those nodes? Well they are not yet anywhere, but with <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> we can easily retrieve the nodes as well by specifying <code class="docutils literal notranslate"><span class="pre">nodes=True</span></code>, when parsing the streets:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Parse nodes and edges</span>
<span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">osm</span><span class="o">.</span><span class="n">get_network</span><span class="p">(</span><span class="n">network_type</span><span class="o">=</span><span class="s2">&quot;driving&quot;</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Plot the data</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Zoom in to take a closer look</span>
<span class="c1">#ax.set_xlim([24.9375, 24.945])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">60.17</span><span class="p">,</span> <span class="mf">60.173</span><span class="p">])</span>
</pre></div>
</div>
<p>Okay, as we can see now we have both the roads (i.e. <em>edges</em>) and the nodes that connect the street elements together (in red) that are typically intersections. However, we can see that many of the nodes are in locations that are clearly not intersections. This is intented behavior to ensure that we have full <strong>connectivity</strong> in our network. We can at later stage clean and simplify this network by merging all roads that belong to the same link (i.e. street elements that are between two intersections) which also reduces the size of the network.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In OSM, the street topology is typically not directly suitable for graph traversal due to missing nodes at intersections which means that the roads are not splitted at those locations. The consequence of this, is that it is not possible to make a turn if there is no intersection present in the data structure. Hence, <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> will separate all road segments/geometries into individual rows in the data.</p>
</div>
<p>Let’s take a look what our nodes data look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nodes</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>As we can see, the <code class="docutils literal notranslate"><span class="pre">nodes</span></code> GeoDataFrame contains information about the coordinates of each node as well as a unique <code class="docutils literal notranslate"><span class="pre">id</span></code> for each node. These <code class="docutils literal notranslate"><span class="pre">id</span></code> values are used to determine the connectivity in our network. Hence, <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> has also added two columns to the <code class="docutils literal notranslate"><span class="pre">edges</span></code> GeoDataFrame that specify <strong>from</strong> and <strong>to</strong> ids for each edge. Column <code class="docutils literal notranslate"><span class="pre">u</span></code> contains information about the <strong>from-id</strong> and column <code class="docutils literal notranslate"><span class="pre">v</span></code> about the <strong>to-id</strong> accordingly:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check last four columns</span>
<span class="n">edges</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
</pre></div>
</div>
<p>We can see that the geometries are now stored as <code class="docutils literal notranslate"><span class="pre">LineString</span></code> instead of <code class="docutils literal notranslate"><span class="pre">MultiLineString</span></code>. At this point, we can fix the issue related to having some pedestrian roads in our network. We can do this by removing all edges from out GeoDataFrame that have <code class="docutils literal notranslate"><span class="pre">highway</span></code> value in <code class="docutils literal notranslate"><span class="pre">'cycleway',</span> <span class="pre">'footway',</span> <span class="pre">'pedestrian',</span> <span class="pre">'trail',</span> <span class="pre">'crossing'</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;highway&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s1">&#39;cycleway&#39;</span><span class="p">,</span> <span class="s1">&#39;footway&#39;</span><span class="p">,</span> <span class="s1">&#39;pedestrian&#39;</span><span class="p">,</span> <span class="s1">&#39;trail&#39;</span><span class="p">,</span> <span class="s1">&#39;crossing&#39;</span><span class="p">])]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">edges</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we can see, that some of the isolated edges were removed from the data. The character <code class="docutils literal notranslate"><span class="pre">~</span></code> (tilde) in the command above is a <em>negation</em> operator that is handy if you want to e.g. remove some rows from your GeoDataFrame based on criteria such as we used here.</p>
</section>
</section>
<section id="modify-the-data">
<h2>2. Modify the data<a class="headerlink" href="#modify-the-data" title="Permalink to this headline">#</a></h2>
<p>At this stage, we have the necessary components to build a routable graph (nodes and edges) based on distance. However, in real life the network distance is not the best cost metric to use, because the shortest path (based on distance) is not necessarily always the optimal route in terms of <strong>travel time</strong>. Time is typically the measure that people value more (plus it is easier to comprehend), so at this stage we want to <strong>add a new cost attribute</strong> to our edges GeoDataFrame that converts the metric distance information to travel time (in seconds) based on following formula:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;distance-in-meters&gt;</span> <span class="pre">/</span> <span class="pre">(&lt;speed-limit-kmph&gt;</span> <span class="pre">/</span> <span class="pre">3.6)</span></code></p></li>
</ul>
<p>Before we can do this calculation, we need to ensure that all rows in <code class="docutils literal notranslate"><span class="pre">maxspeed</span></code> column have information about the speed limit. Let’s check the value counts of the column and also include information about the <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values with <code class="docutils literal notranslate"><span class="pre">dropna</span></code> parameter:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Count values</span>
<span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>As we can see, the rows which do not contain information about the speed limit is the second largest group in our data. Hence, we need to apply a criteria to fill these gaps. We can do this based on following “rule of thumb” criteria in Finland (notice that these vary country by country):</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Road class</p></th>
<th class="head"><p>Speed limit within urban region</p></th>
<th class="head"><p>Speed limit outside urban region</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>motorway</p></td>
<td><p>100</p></td>
<td><p>120</p></td>
</tr>
<tr class="row-odd"><td><p>motorway_link</p></td>
<td><p>80</p></td>
<td><p>80</p></td>
</tr>
<tr class="row-even"><td><p>trunk</p></td>
<td><p>60</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-odd"><td><p>trunk_link</p></td>
<td><p>60</p></td>
<td><p>60</p></td>
</tr>
<tr class="row-even"><td><p>primary</p></td>
<td><p>50</p></td>
<td><p>80</p></td>
</tr>
<tr class="row-odd"><td><p>primary_link</p></td>
<td><p>50</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-even"><td><p>secondary</p></td>
<td><p>50</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-odd"><td><p>secondary_link</p></td>
<td><p>50</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-even"><td><p>tertiary</p></td>
<td><p>50</p></td>
<td><p>60</p></td>
</tr>
<tr class="row-odd"><td><p>tertiary_link</p></td>
<td><p>50</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-even"><td><p>unclassified</p></td>
<td><p>50</p></td>
<td><p>80</p></td>
</tr>
<tr class="row-odd"><td><p>unclassified_link</p></td>
<td><p>50</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-even"><td><p>residential</p></td>
<td><p>50</p></td>
<td><p>80</p></td>
</tr>
<tr class="row-odd"><td><p>living_street</p></td>
<td><p>20</p></td>
<td><p>NA</p></td>
</tr>
<tr class="row-even"><td><p>service</p></td>
<td><p>30</p></td>
<td><p>NA</p></td>
</tr>
<tr class="row-odd"><td><p>other</p></td>
<td><p>50</p></td>
<td><p>80</p></td>
</tr>
</tbody>
</table>
<p>For simplicity, we can consider that all the roads in Helsinki Region follows the <em>within urban region</em> speed limits, although this is not exactly true (the higher speed limits start somewhere at the outer parts of the city region). For making the speed limit values more robust / correct, you could use data about urban/rural classification which is available in Finland from <a class="reference external" href="https://www.avoindata.fi/data/fi/dataset/kaupunki-maaseutu-luokitus-ykr">Finnish Environment Institute</a>. Let’s first convert our <code class="docutils literal notranslate"><span class="pre">maxspeed</span></code> values to integers using <code class="docutils literal notranslate"><span class="pre">astype()</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Int64Dtype</span><span class="p">())</span>
<span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</pre></div>
</div>
<p>As we can see, now the maxspeed values are stored in integer format inside an <code class="docutils literal notranslate"><span class="pre">IntegerArray</span></code>, and the <code class="docutils literal notranslate"><span class="pre">None</span></code> values were converted into <code class="docutils literal notranslate"><span class="pre">pandas.NA</span></code> objects that are assigned with <code class="docutils literal notranslate"><span class="pre">&lt;NA&gt;</span></code>. Now we can create a function that returns a numeric value for different road classes based on the criteria in the table above:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">road_class_to_kmph</span><span class="p">(</span><span class="n">road_class</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a speed limit value based on road class, </span>
<span class="sd">    using typical Finnish speed limit values within urban regions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">road_class</span> <span class="o">==</span> <span class="s2">&quot;motorway&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">100</span>
    <span class="k">elif</span> <span class="n">road_class</span> <span class="o">==</span> <span class="s2">&quot;motorway_link&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">80</span>
    <span class="k">elif</span> <span class="n">road_class</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;trunk&quot;</span><span class="p">,</span> <span class="s2">&quot;trunk_link&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="mi">60</span>
    <span class="k">elif</span> <span class="n">road_class</span> <span class="o">==</span> <span class="s2">&quot;service&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">30</span>
    <span class="k">elif</span> <span class="n">road_class</span> <span class="o">==</span> <span class="s2">&quot;living_street&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">20</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">50</span>
</pre></div>
</div>
<p>Now we can apply this function to all rows that <strong>do not have speed limit information</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Separate rows with / without speed limit information </span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>
<span class="n">edges_without_maxspeed</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">edges_with_maxspeed</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Apply the function and update the maxspeed</span>
<span class="n">edges_without_maxspeed</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges_without_maxspeed</span><span class="p">[</span><span class="s2">&quot;highway&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">road_class_to_kmph</span><span class="p">)</span>
<span class="n">edges_without_maxspeed</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">,</span> <span class="s2">&quot;highway&quot;</span><span class="p">]]</span>
</pre></div>
</div>
<p>Okay, as we can see now the <code class="docutils literal notranslate"><span class="pre">maxspeed</span></code> value have been updated according our criteria, and e.g. the <code class="docutils literal notranslate"><span class="pre">service</span></code> road class have been given the speed limit 30 kmph. Now we can recreate the edges GeoDataFrame by combining the two frames:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges_with_maxspeed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges_without_maxspeed</span><span class="p">)</span>
<span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</pre></div>
</div>
<p>Great, now all of our edges have information about the speed limit. We can also visualize them:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert the value into regular integer Series (the plotting requires having Series instead of IntegerArray) </span>
<span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we can calculate the travel time in seconds using the formula we saw earlier and add that as a new cost attribute for our network:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;travel_time_seconds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">/</span><span class="mf">3.6</span><span class="p">)</span>
<span class="n">edges</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
</pre></div>
</div>
<p>Excellent! Now our GeoDataFrame has all the information we need for creating a graph that can be used to conduct shortest path analysis based on length or travel time. Notice that here we assume that the cars can drive with the same speed as what the speed limit is. Considering the urban dynamics and traffic congestion, this assumption might not hold, but for simplicity, we assume so in this tutorial.</p>
</section>
<section id="a-build-a-directed-graph-from-scratch-see-3b-for-easier-approach">
<h2>3a. Build a directed graph from scratch (see 3b for easier approach)<a class="headerlink" href="#a-build-a-directed-graph-from-scratch-see-3b-for-easier-approach" title="Permalink to this headline">#</a></h2>
<p>Now as we have calculated the travel time for our edges. We still need to convert our nodes and edges into a directed graph, so that we can start using it for routing. There are easy-to-use functionalities for doing this in <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> and <code class="docutils literal notranslate"><span class="pre">osmnx</span></code>, but we will do this manually by ourselves, so that you understand what is going on under the hood.</p>
<p>First of all, we need to take care that our edges correctly represent a <code class="docutils literal notranslate"><span class="pre">directed</span></code> network. This means that we need to look at the values in <code class="docutils literal notranslate"><span class="pre">oneway</span></code> column and modify our edges based on the rules set in that column. If the <code class="docutils literal notranslate"><span class="pre">oneway</span></code> is <code class="docutils literal notranslate"><span class="pre">'yes'</span></code>, it means that the street can be driven only to one direction, and if it is <code class="docutils literal notranslate"><span class="pre">None</span></code> or has a value <code class="docutils literal notranslate"><span class="pre">&quot;no&quot;</span></code>, then that road can be driven to both directions. This means that we need to make new duplicate edge and reversing the from-id and to-id values in the <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> columns. In addition, value <code class="docutils literal notranslate"><span class="pre">-1</span></code> in the <code class="docutils literal notranslate"><span class="pre">oneway</span></code> column means that the road can only be driven to one direction but <strong>against</strong> the digitization direction. In such cases, we need to flip the <em>to-id</em> (<code class="docutils literal notranslate"><span class="pre">u</span></code>) and <em>from-id</em> (<code class="docutils literal notranslate"><span class="pre">u</span></code>) values so that the directionality in the graph is correctly specified. Let’s first check what kind of values we have in the <code class="docutils literal notranslate"><span class="pre">oneway</span></code> column:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;oneway&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</pre></div>
</div>
<p>Okay, in this small sample of ours, we do not seem to have any <em>reversed</em> oneway edges (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) which makes things a bit easier for us, as we do not need to swap the from and to-ids. But we still need to ensure that our data is presented in such a way that a directed graph can be made out of it. Hence, we need to:</p>
<ol class="simple">
<li><p>Separate one-way and two-way streets</p></li>
<li><p>For two-way streets, we need to create edges to opposite direction</p></li>
<li><p>(For one-way streets, we do not need to do anything in this case because there weren’t any <code class="docutils literal notranslate"><span class="pre">-1</span></code> values)</p></li>
</ol>
<p>Let’s start from step 1 and separate the one-way and two-way streets:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">oneway</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;oneway&quot;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;yes&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
<span class="n">twoway</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;oneway&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s2">&quot;no&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">])]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
</pre></div>
</div>
<p>Let’s ensure that we have successfully selected all rows in our data. Doing these kind of checks e.g. with <code class="docutils literal notranslate"><span class="pre">assert</span></code> is always good to do, when you e.g. split your dataset into two groups:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">oneway</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">twoway</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
<p>Okay, we seem to be okay because the <code class="docutils literal notranslate"><span class="pre">assert</span></code> did not raise any errors. Next, we want to continue processing the <code class="docutils literal notranslate"><span class="pre">twoway</span></code> edges and create edges for other direction. Let’s start by creating a copy out of the <code class="docutils literal notranslate"><span class="pre">twoway</span></code> edges for opposite direction:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make a copy out of twoway edges</span>
<span class="n">opposite_direction</span> <span class="o">=</span> <span class="n">twoway</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Now the frames should be identical</span>
<span class="n">pd</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_frame_equal</span><span class="p">(</span><span class="n">twoway</span><span class="p">,</span> <span class="n">opposite_direction</span><span class="p">)</span>
</pre></div>
</div>
<p>Okay good, now we have an identical copy of the twoway edges. Next, to change the <strong>direction</strong> of the edges in <code class="docutils literal notranslate"><span class="pre">opposite_direction</span></code> we simply need to specify that all the values in <code class="docutils literal notranslate"><span class="pre">u</span></code> becomes <code class="docutils literal notranslate"><span class="pre">v</span></code>, and all the values in <code class="docutils literal notranslate"><span class="pre">v</span></code> becomes <code class="docutils literal notranslate"><span class="pre">u</span></code>. The easiest way of achieving this is simply by renaming the columns because we do not need to do anything else with the values:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">opposite_direction</span> <span class="o">=</span> <span class="n">opposite_direction</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="s2">&quot;u&quot;</span><span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s check the changes</span>
<span class="nb">print</span><span class="p">(</span><span class="n">twoway</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">opposite_direction</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]])</span>
</pre></div>
</div>
<p>Okay, as we can see now the from/to ids of the edges have been swapped, which is visible at row index <code class="docutils literal notranslate"><span class="pre">0</span></code> (the <code class="docutils literal notranslate"><span class="pre">Name</span></code> here tells us about the index). Now we need to merge all these edges together into a single GeoDataFrame:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">directed_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">oneway</span><span class="p">,</span> <span class="n">twoway</span><span class="p">,</span> <span class="n">opposite_direction</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original edge count:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Directed edge count:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">directed_edges</span><span class="p">))</span>
</pre></div>
</div>
<p>As we can see, now the number of edges has increased because we needed to create those opposite-direction extra edges for the two-way streets. Now we are ready to convert this GeoDataFrame into a graph! In this tutorial, we will use <a class="reference external" href="https://networkx.org/documentation/stable/">NetworkX library</a> for routing. We need to convert our <code class="docutils literal notranslate"><span class="pre">nodes</span></code> and <code class="docutils literal notranslate"><span class="pre">directed_edges</span></code> into a data structures that can be ingested by the <code class="docutils literal notranslate"><span class="pre">networkx.MultiDiGraph</span></code> object. Basically, we need to parse edge and node attributes from our GeoDataFrames, and create an <em>edge list</em> having information about the from-ids and to-ids.</p>
<p>NetworkX uses a “dictionary of dictionaries of dictionaries” as the basic network data structure. This allows fast lookup with reasonable storage for large sparse networks. Let’s start by converting the edge and nodes attribute information into a <code class="docutils literal notranslate"><span class="pre">dictionary</span></code> format:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specify &quot;id&quot; as the index for nodes</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">([</span><span class="kc">None</span><span class="p">])</span>

<span class="n">edge_attributes</span> <span class="o">=</span> <span class="n">directed_edges</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
<span class="n">node_attributes</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now the edges are inside a dictionary where the index number if the key, </span>
<span class="c1"># and as value we have another dictionary with all the attribute values for given row</span>
<span class="n">edge_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Networkx <a class="reference external" href="https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_nodes_from.html">wants the node attributes</a> to be in a list of tuples such as <code class="docutils literal notranslate"><span class="pre">[(node-id-0,</span> <span class="pre">dict_of_node_attributes_at_0),</span> <span class="pre">(node-id-1,</span> <span class="pre">dict_of_node_attributes_at_1)]</span></code>. Let’s do this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">node_attributes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_attributes</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">node_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Okay, now the node attributes follow the specified structure. At this point, our edge and node attributes are ready. Next, we need to create an edge list that specify the network structure of the MultiDiGraph (i.e. how the nodes are connected together). This can be done easily by iterating over the edges and adding the <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> column information and <em>edge attributes</em> into a list.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">node_ids</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">directed_edges</span><span class="p">)):</span>
    <span class="n">e_attrib</span> <span class="o">=</span> <span class="n">edge_attributes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">from_node_id</span> <span class="o">=</span> <span class="n">e_attrib</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span>
    <span class="n">to_node_id</span> <span class="o">=</span> <span class="n">e_attrib</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>
    
    <span class="c1"># Both from_node_id and to_node_id needs to exist in our nodes </span>
    <span class="k">if</span> <span class="n">from_node_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Did not find from-node&quot;</span><span class="p">,</span> <span class="n">from_node_id</span><span class="p">)</span>
        <span class="k">continue</span>
    <span class="k">if</span> <span class="n">to_node_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Did not find to-node&quot;</span><span class="p">,</span> <span class="n">to_node_id</span><span class="p">)</span>
        <span class="k">continue</span>
    
    <span class="n">edge</span> <span class="o">=</span> <span class="p">[</span><span class="n">from_node_id</span><span class="p">,</span> <span class="n">to_node_id</span><span class="p">,</span> <span class="n">e_attrib</span><span class="p">]</span>
    <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the graph</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">node_attributes</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edge_list</span><span class="p">);</span>

<span class="c1"># What do we have?</span>
<span class="n">graph</span>
</pre></div>
</div>
<p>Awesome, now we have created a NetworkX MultiDigraph object that we can use for doing routing. This hopefully gives you an idea how it is possible to create a routable graph from street network. Similar approach can be used for constructing routable graphs from many different data sources, such as Digiroad which is the national street database in Finland. Naturally the code needs to be adjusted to reflect the data structure of Digiroad or any other street network data that you want to use. You need to have some information about the allowed driving directions as well as the from and to-ids for each edge. These ids are not necessarily present in the data by default. In such cases, you can create your own ids e.g. based on vertices of the edge geometries (i.e. the x-y coordinates of the vertices can be used to create a unique node-id).</p>
</section>
<section id="b-build-a-directed-graph-with-pyrosm">
<h2>3b. Build a directed graph with pyrosm<a class="headerlink" href="#b-build-a-directed-graph-with-pyrosm" title="Permalink to this headline">#</a></h2>
<p>Naturally, if you are using OpenStreetMap data, you do not necessarily need to build graphs yourself, because <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> library (as well as <code class="docutils literal notranslate"><span class="pre">OSMnx</span></code>) contains functions that does all this work for you. Let’s see how we can create a routable NetworkX graph using <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> with one command:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">osm</span><span class="o">.</span><span class="n">to_graph</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">graph_type</span><span class="o">=</span><span class="s2">&quot;networkx&quot;</span><span class="p">)</span>
<span class="n">G</span>
</pre></div>
</div>
<p>Now we have a similar routable graph, but <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> actually does some additional steps in the background. By default, <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> cleans all <strong>unconnected</strong> edges from the graph and only keeps edges that can be reached from every part of the network. In addition, <code class="docutils literal notranslate"><span class="pre">pyrosm</span></code> automatically modifies the graph attribute information in a way that they are compatible with <code class="docutils literal notranslate"><span class="pre">OSMnx</span></code> that provides many handy functionalities to work with graphs. Such as plotting an interactive map based on the graph:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">osmnx</span> <span class="k">as</span> <span class="nn">ox</span> 
<span class="n">ox</span><span class="o">.</span><span class="n">plot_graph_folium</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="routing-with-networkx">
<h2>4. Routing with NetworkX<a class="headerlink" href="#routing-with-networkx" title="Permalink to this headline">#</a></h2>
<p>Now we have everything we need to start routing with NetworkX (based on driving distance or travel time). But first, let’s again go through some basics about routing.</p>
<section id="basic-logic-in-routing">
<h3>Basic logic in routing<a class="headerlink" href="#basic-logic-in-routing" title="Permalink to this headline">#</a></h3>
<p>Most (if not all) routing algorithms work more or less in a similar manner. The basic steps for finding an optimal route from A to B, is to:</p>
<ol class="simple">
<li><p>Find the nearest node for origin location * (+ get info about its node-id and distance between origin and node)</p></li>
<li><p>Find the nearest node for destination location * (+ get info about its node-id and distance between origin and node)</p></li>
<li><p>Use a routing algorithm to find the shortest path between A and B</p></li>
<li><p>Retrieve edge attributes for the given route(s) and summarize them (can be distance, time, CO2, or whatever)</p></li>
</ol>
<p>* in more advanced implementations you might search for the closest edge</p>
<p>This same logic should be applied always when searching for an optimal route between a single origin to a single destination, or when calculating one-to-many -type of routing queries (producing e.g. travel time matrices).</p>
</section>
</section>
<section id="find-the-optimal-route-between-two-locations">
<h2>Find the optimal route between two locations<a class="headerlink" href="#find-the-optimal-route-between-two-locations" title="Permalink to this headline">#</a></h2>
<p>Next, we will learn how to find the shortest path between two locations using <a class="reference external" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra’s</a> algorithm.</p>
<p>First, let’s find the closest nodes for two locations that are located in the area. OSMnx provides a handly function for geocoding an address <code class="docutils literal notranslate"><span class="pre">ox.geocode()</span></code>. We can use that to retrieve the x and y coordinates of our origin and destination.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># OSM data is in WGS84 so typically we need to use lat/lon coordinates when searching for the closest node</span>

<span class="c1"># Origin</span>
<span class="n">orig_address</span> <span class="o">=</span> <span class="s2">&quot;Simonkatu 3, Helsinki&quot;</span>
<span class="n">orig_y</span><span class="p">,</span> <span class="n">orig_x</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">geocode</span><span class="p">(</span><span class="n">orig_address</span><span class="p">)</span>  <span class="c1"># notice the coordinate order (y, x)!</span>

<span class="c1"># Destination</span>
<span class="n">dest_address</span> <span class="o">=</span> <span class="s2">&quot;Unioninkatu 33, Helsinki&quot;</span>
<span class="n">dest_y</span><span class="p">,</span> <span class="n">dest_x</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">geocode</span><span class="p">(</span><span class="n">dest_address</span><span class="p">)</span> 

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Origin coords:&quot;</span><span class="p">,</span> <span class="n">orig_x</span><span class="p">,</span> <span class="n">orig_y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Destination coords:&quot;</span><span class="p">,</span> <span class="n">dest_x</span><span class="p">,</span> <span class="n">dest_y</span><span class="p">)</span>
</pre></div>
</div>
<p>Okay, now we have coordinates for our origin and destination.</p>
<section id="find-the-nearest-nodes">
<h3>Find the nearest nodes<a class="headerlink" href="#find-the-nearest-nodes" title="Permalink to this headline">#</a></h3>
<p>Next, we need to find the closest nodes from the graph for both of our locations. For calculating the closest point we use <code class="docutils literal notranslate"><span class="pre">ox.distance.nearest_nodes()</span></code> -function and specify <code class="docutils literal notranslate"><span class="pre">return_dist=True</span></code> to get the distance in meters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 1. Find the closest nodes for origin and destination</span>
<span class="n">orig_node_id</span><span class="p">,</span> <span class="n">dist_to_orig</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">nearest_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">orig_x</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">orig_y</span><span class="p">,</span> <span class="n">return_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">dest_node_id</span><span class="p">,</span> <span class="n">dist_to_dest</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">nearest_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">dest_x</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">dest_y</span><span class="p">,</span> <span class="n">return_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Origin node-id:&quot;</span><span class="p">,</span> <span class="n">orig_node_id</span><span class="p">,</span> <span class="s2">&quot;and distance:&quot;</span><span class="p">,</span> <span class="n">dist_to_orig</span><span class="p">,</span> <span class="s2">&quot;meters.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Destination node-id:&quot;</span><span class="p">,</span> <span class="n">dest_node_id</span><span class="p">,</span> <span class="s2">&quot;and distance:&quot;</span><span class="p">,</span> <span class="n">dist_to_dest</span><span class="p">,</span> <span class="s2">&quot;meters.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we are ready to start the actual routing with NetworkX.</p>
</section>
<section id="find-the-fastest-route-by-distance-time">
<h3>Find the fastest route by distance / time<a class="headerlink" href="#find-the-fastest-route-by-distance-time" title="Permalink to this headline">#</a></h3>
<p>Now we can do the routing and find the shortest path between the origin and target locations
by using the <code class="docutils literal notranslate"><span class="pre">dijkstra_path()</span></code> function of NetworkX. For getting only the cumulative cost of the trip, we can directly use a function <code class="docutils literal notranslate"><span class="pre">dijkstra_path_length()</span></code> that returns the travel time without the actual path.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">weight</span></code> -parameter we can specify the attribute that we want to use as cost/impedance. We have now three possible weight attributes available: <code class="docutils literal notranslate"><span class="pre">'length'</span></code> and <code class="docutils literal notranslate"><span class="pre">'travel_time_seconds'</span></code>.</p>
<ul class="simple">
<li><p>Let’s first calculate the routes between locations by walking and cycling, and also retrieve the travel times</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate the paths by walking and cycling</span>
<span class="n">metric_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">dest_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">)</span>
<span class="n">time_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">dest_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;travel_time_seconds&#39;</span><span class="p">)</span>

<span class="c1"># Get also the actual travel times (summarize)</span>
<span class="n">travel_length</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">dest_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">)</span>
<span class="n">travel_time</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">dest_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;travel_time_seconds&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Okay, that was it! Let’s now see what we got as results by visualizing the results.</p>
<p>For visualization purposes, we can use a handy function again from OSMnx called <code class="docutils literal notranslate"><span class="pre">ox.plot_graph_route()</span></code> (for static) or <code class="docutils literal notranslate"><span class="pre">ox.plot_route_folium()</span></code> (for interactive plot).</p>
<ul class="simple">
<li><p>Let’s first make static maps</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Shortest path based on distance</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">metric_path</span><span class="p">)</span>

<span class="c1"># Add the travel time as title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Shortest path distance </span><span class="si">{t: .1f}</span><span class="s2"> meters.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">travel_length</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">time_path</span><span class="p">)</span>

<span class="c1"># Add the travel time as title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Travel time </span><span class="si">{t: .1f}</span><span class="s2"> minutes.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">travel_time</span><span class="o">/</span><span class="mi">60</span><span class="p">))</span>
</pre></div>
</div>
<p>Great! Now we have successfully found the optimal route between our origin and destination and we also have estimates about the travel time that it takes to travel between the locations by walking and cycling. As we can see, the route for both travel modes is exactly the same which is natural, as the only thing that changed here was the constant travel speed.</p>
<ul class="simple">
<li><p>Let’s still finally see an example how you can plot a nice interactive map out of our results with OSMnx:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ox</span><span class="o">.</span><span class="n">plot_route_folium</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">time_path</span><span class="p">,</span> <span class="n">popup_attribute</span><span class="o">=</span><span class="s1">&#39;travel_time_seconds&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="calculate-travel-times-from-one-to-many-locations">
<h2>Calculate travel times from one to many locations<a class="headerlink" href="#calculate-travel-times-from-one-to-many-locations" title="Permalink to this headline">#</a></h2>
<p>When trying to understand the accessibility of a specific location, you typically want to look at travel times between multiple locations (one-to-many) or use isochrones (travel time contours).</p>
<ul class="simple">
<li><p>Let’s see how we can calculate travel times from the origin node, to all other nodes in our graph using NetworkX function <code class="docutils literal notranslate"><span class="pre">single_source_dijkstra_path_length()</span></code>:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate walk travel times originating from one location</span>
<span class="n">travel_times</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_dijkstra_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;travel_time_seconds&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># What did we get?</span>
<span class="c1">#travel_times</span>
</pre></div>
</div>
<p>As we can see, the result is a dictionary where we have the <strong>node_id</strong> as keys and the <strong>travel time</strong> as values.</p>
<p>For visualizing this information, we need to join this data with the nodes. For doing this, we can first convert the result to DataFrame and then we can easily merge the information with the nodes GeoDataFrame.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="c1"># Convert to DataFrame and add column names</span>
<span class="n">travel_times_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">travel_times</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="nb">list</span><span class="p">(</span><span class="n">travel_times</span><span class="o">.</span><span class="n">values</span><span class="p">())])</span><span class="o">.</span><span class="n">T</span>
<span class="n">travel_times_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">,</span> <span class="s1">&#39;travel_time&#39;</span><span class="p">]</span>

<span class="c1"># What do we have now?</span>
<span class="n">travel_times_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Great! Now we have the travel times <strong>from origin</strong> to all other nodes in the graph.</p>
<ul class="simple">
<li><p>Let’s finally merge the data with the nodes GeoDataFrame and visualize the results</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the nodes</span>
<span class="n">nodes</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>As we can see, the <code class="docutils literal notranslate"><span class="pre">node_id</span></code> in the nodes GeoDataFrame can be found from the <code class="docutils literal notranslate"><span class="pre">index</span></code> of the gdf as well as from the column <code class="docutils literal notranslate"><span class="pre">osmid</span></code>.</p>
<ul class="simple">
<li><p>Let’s merge these two datasets:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Merge the datasets</span>
<span class="n">nodes_viz</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">travel_times_df</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s1">&#39;node_id&#39;</span><span class="p">)</span>

<span class="c1"># Check</span>
<span class="n">nodes_viz</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Okay, now we have also the travel times associated for each node.</p>
<ul class="simple">
<li><p>Let’s visualize this:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>

<span class="c1"># Make a GeoDataFrame for the origin point so that we can visualize it</span>
<span class="n">orig</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">orig_x</span><span class="p">,</span> <span class="n">orig_y</span><span class="p">)]},</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="s1">&#39;epsg:4326&#39;</span><span class="p">)</span>

<span class="c1"># Plot the results with edges and the origin point (green)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">nodes_viz</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;travel_time&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdYlBu&#39;</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;natural_breaks&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Okay, as we can see now we have quickly calculated the travel times for each node in the graph using a single call.</p>
<p>If you would have for example a predefined grid, you could find the nearest node for each grid centroid to produce a more matrix-like result.</p>
<section id="alternative-approach-ego-graph">
<h3>Alternative approach - Ego graph<a class="headerlink" href="#alternative-approach-ego-graph" title="Permalink to this headline">#</a></h3>
<p>Alternatively, it is possible to directly set a specific time limit and restrict <strong>how long the graph is travelled</strong> from the origin, and return that subgraph for the user.</p>
<ul class="simple">
<li><p>Let’s see an example:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Take a subgraph until 1 minutes by driving (60 seconds)</span>
<span class="n">subgraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">ego_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="s1">&#39;travel_time_seconds&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph</span><span class="p">(</span><span class="n">subgraph</span><span class="p">)</span>
</pre></div>
</div>
<p>As we can see, with this approach we can retrieve a partial graph that we could for example visualize with different colors, or e.g. subset the extent of our accessibility analysis to cover only specific range from the source.</p>
</section>
</section>
<section id="larger-scale-analysis">
<h2>Larger scale analysis<a class="headerlink" href="#larger-scale-analysis" title="Permalink to this headline">#</a></h2>
<p>We can very easily create a travel time map covering larger areas as well. This is how you could calculate travel times by car from city center of Helsinki to other parts of the region:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyrosm</span> <span class="kn">import</span> <span class="n">OSM</span><span class="p">,</span> <span class="n">get_data</span>
<span class="kn">import</span> <span class="nn">osmnx</span> <span class="k">as</span> <span class="nn">ox</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="k">def</span> <span class="nf">road_class_to_kmph</span><span class="p">(</span><span class="n">road_class</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a speed limit value based on road class, </span>
<span class="sd">    using typical Finnish speed limit values within urban regions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">road_class</span> <span class="o">==</span> <span class="s2">&quot;motorway&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">100</span>
    <span class="k">elif</span> <span class="n">road_class</span> <span class="o">==</span> <span class="s2">&quot;motorway_link&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">80</span>
    <span class="k">elif</span> <span class="n">road_class</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;trunk&quot;</span><span class="p">,</span> <span class="s2">&quot;trunk_link&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="mi">60</span>
    <span class="k">elif</span> <span class="n">road_class</span> <span class="o">==</span> <span class="s2">&quot;service&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">30</span>
    <span class="k">elif</span> <span class="n">road_class</span> <span class="o">==</span> <span class="s2">&quot;living_street&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">20</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">50</span>
    
<span class="k">def</span> <span class="nf">assign_speed_limits</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
    <span class="c1"># Separate rows with / without speed limit information </span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>
    <span class="n">edges_without_maxspeed</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">edges_with_maxspeed</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Apply the function and update the maxspeed</span>
    <span class="n">edges_without_maxspeed</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges_without_maxspeed</span><span class="p">[</span><span class="s2">&quot;highway&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">road_class_to_kmph</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">edges_with_maxspeed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges_without_maxspeed</span><span class="p">)</span>
    <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;travel_time_seconds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;maxspeed&quot;</span><span class="p">]</span><span class="o">/</span><span class="mf">3.6</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">edges</span>
    
<span class="c1"># Fetch data for Helsinki</span>
<span class="n">osm</span> <span class="o">=</span> <span class="n">OSM</span><span class="p">(</span><span class="n">get_data</span><span class="p">(</span><span class="s2">&quot;helsinki&quot;</span><span class="p">))</span>
<span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">osm</span><span class="o">.</span><span class="n">get_network</span><span class="p">(</span><span class="n">network_type</span><span class="o">=</span><span class="s2">&quot;driving&quot;</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Assign speed limits for missing ones based on road classs information</span>
<span class="n">edges</span> <span class="o">=</span> <span class="n">assign_speed_limits</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

<span class="c1"># Remove unnecessary columns to reduce memory footprint </span>
<span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[[</span><span class="s2">&quot;highway&quot;</span><span class="p">,</span> <span class="s2">&quot;oneway&quot;</span><span class="p">,</span> <span class="s2">&quot;travel_time_seconds&quot;</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]]</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a graph</span>
<span class="n">G2</span> <span class="o">=</span> <span class="n">osm</span><span class="o">.</span><span class="n">to_graph</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">graph_type</span><span class="o">=</span><span class="s2">&quot;networkx&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate travel times from central railway station</span>
<span class="n">orig_address</span> <span class="o">=</span> <span class="s2">&quot;Rautatientori, Helsinki&quot;</span>
<span class="n">orig_y</span><span class="p">,</span> <span class="n">orig_x</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">geocode</span><span class="p">(</span><span class="n">orig_address</span><span class="p">)</span>  <span class="c1"># notice the coordinate order (y, x)!</span>
<span class="n">orig_node_id</span><span class="p">,</span> <span class="n">dist_to_orig</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">nearest_nodes</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">orig_x</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">orig_y</span><span class="p">,</span> <span class="n">return_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">travel_times</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_dijkstra_path_length</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;travel_time_seconds&#39;</span><span class="p">)</span>

<span class="c1"># Convert to DataFrame and add column names</span>
<span class="n">travel_times_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">travel_times</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="nb">list</span><span class="p">(</span><span class="n">travel_times</span><span class="o">.</span><span class="n">values</span><span class="p">())])</span><span class="o">.</span><span class="n">T</span>
<span class="n">travel_times_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">,</span> <span class="s1">&#39;travel_time&#39;</span><span class="p">]</span>
<span class="n">nodes_t</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">travel_times_df</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s1">&#39;node_id&#39;</span><span class="p">)</span>

<span class="c1"># Convert travel time to minutes</span>
<span class="n">nodes_t</span><span class="p">[</span><span class="s2">&quot;travel_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nodes_t</span><span class="p">[</span><span class="s2">&quot;travel_time&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the results</span>
<span class="n">main_roads</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;highway&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s2">&quot;motorway&quot;</span><span class="p">,</span> <span class="s2">&quot;motorway_link&quot;</span><span class="p">,</span> <span class="s2">&quot;trunk&quot;</span><span class="p">,</span> <span class="s2">&quot;trunk_link&quot;</span><span class="p">,</span> <span class="s2">&quot;primary&quot;</span><span class="p">,</span> <span class="s2">&quot;primary_link&quot;</span><span class="p">])]</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">main_roads</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">nodes_t</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;travel_time&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdYlBu&#39;</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;natural_breaks&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>As a result, we have a map that shows travel times by driving from the central railway station of Helsinki. We can see that if assuming that you could drive according the speed limits, it would be possible to reach even the farthest parts of the region in approximately 30 minutes. Naturally this is not typically possible because of the congestion. Considering congestion in the travel times can also be taken into account by creating a model that integrates information from floating car measurements (GPS data), but it is out of scope of this tutorial.</p>
</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp<br/>
  
      &copy; Copyright 2020-2022, Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>