
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Data wrangling, grouping and aggregation</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/pythongis.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/pythongis-logo.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part I - Python essentials
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../chapter-01/index.html">
   Getting started
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-01/nb/00-motivation.html">
     Motivation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-01/nb/01-computers-and-programs.html">
     Computers and programs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-01/nb/02-why-python.html">
     Why Python?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-01/nb/03-jupyter.html">
     Jupyter notebooks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-01/nb/04-coding-with-an-ide.html">
     Other coding environments
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-01/nb/05-installation.html">
     Installation and setup
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-01/nb/06-references.html">
     References
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../chapter-02/index.html">
   Basic programming concepts
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-02/nb/00-python-basics.html">
     Basic elements of Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-02/nb/01-for-loops.html">
     for loops
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-02/nb/02-conditional-statements.html">
     Conditional statements
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-02/nb/03-functions.html">
     Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-02/nb/04-writing-scripts.html">
     Writing script files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-02/nb/05-modules.html">
     Loading and using modules
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-02/nb/06-exercises.html">
     Exercises
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-02/nb/07-references.html">
     References
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../index.html">
   Introduction to data analysis with Python
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../nb/00-pandas-basics.html">
     Getting started with pandas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../nb/01-data-manipulation.html">
     Common tabular operations in pandas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../nb/02-data-analysis.html">
     Data wrangling, grouping and aggregation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../nb/03-temporal-data.html">
     Working with temporal data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../nb/04-references.html">
     References
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../chapter-04/index.html">
   Introduction to data visualization
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-04/nb/00-introduction.html">
     Python plotting libraries
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-04/nb/01-plot-anatomy.html">
     Anatomy of a plot
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-04/nb/02-basic-plotting.html">
     Plotting with pandas and matplotlib
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-04/nb/03-subplots.html">
     Creating subplots
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part II - Using Python with GIS
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../part2/index.html">
   Introduction to GIS in Python
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part III - Case studies
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../part3/index.html">
   Geographic data analysis applications
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Back matter
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../back-matter/appendices.html">
   Appendices
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-1.html">
     Version control with git
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-2.html">
     Collaborative coding with GitHub
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-3.html">
     Using Python script files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-4.html">
     Testing and debugging your code
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-5.html">
     Solutions to lesson questions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-6.html">
     Solutions to exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../back-matter/acknowledgements.html">
   Acknowledgements
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../back-matter/nb/glossary.html">
   Glossary
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../authors.html">
   About the authors
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Datasets
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../data/index.html">
   Overview
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../../_sources/part1/chapter-03/md/02-data-analysis.md.txt"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        
        
        <a class="edit-button" href="https://github.com/Python-GIS-book/site/edit/master/part1/chapter-03/md/02-data-analysis.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cleaning-data-while-reading">
   Cleaning data while reading
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#renaming-columns">
   Renaming columns
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#using-functions-with-pandas">
   Using functions with pandas
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#defining-a-function">
     Defining a function
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-a-function-by-iterating-over-rows">
     Using a function by iterating over rows
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-a-function-with-apply">
     Using a function with apply
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#string-slicing">
   String slicing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#grouping-and-aggregating-data">
   Grouping and aggregating data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#case-study-detecting-warm-months">
   Case study: Detecting warm months
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#automating-the-analysis">
   Automating the analysis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#problem-1-read-the-data-and-calculate-basic-statistics">
     Problem 1 - Read the data and calculate basic statistics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#problem-2-select-data-and-compare-temperatures-between-months">
     Problem 2 - Select data and compare temperatures between months
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#problem-3-parse-daily-temperatures-by-aggregating-data">
     Problem 3 - Parse daily temperatures by aggregating data
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#footnotes">
   Footnotes
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Data wrangling, grouping and aggregation</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cleaning-data-while-reading">
   Cleaning data while reading
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#renaming-columns">
   Renaming columns
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#using-functions-with-pandas">
   Using functions with pandas
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#defining-a-function">
     Defining a function
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-a-function-by-iterating-over-rows">
     Using a function by iterating over rows
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-a-function-with-apply">
     Using a function with apply
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#string-slicing">
   String slicing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#grouping-and-aggregating-data">
   Grouping and aggregating data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#case-study-detecting-warm-months">
   Case study: Detecting warm months
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#automating-the-analysis">
   Automating the analysis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#problem-1-read-the-data-and-calculate-basic-statistics">
     Problem 1 - Read the data and calculate basic statistics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#problem-2-select-data-and-compare-temperatures-between-months">
     Problem 2 - Select data and compare temperatures between months
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#problem-3-parse-daily-temperatures-by-aggregating-data">
     Problem 3 - Parse daily temperatures by aggregating data
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#footnotes">
   Footnotes
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="data-wrangling-grouping-and-aggregation">
<h1>Data wrangling, grouping and aggregation<a class="headerlink" href="#data-wrangling-grouping-and-aggregation" title="Permalink to this headline">¶</a></h1>
<p>Next, we will continue working with weather data, but expand our analysis to cover longer periods of data from Finland. In the following, you will learn various useful techniques in pandas to manipulate, group and aggregate the data in different ways that are useful when extracting insights from your data. In the end, you will learn how to create an automated data analysis workflow that can be repeated with multiple input files having a similar structure. As a case study, we will investigate whether January 2020 was the warmest month on record also in Finland, as the month was the warmest one on record globally <a class="footnote-reference brackets" href="#noaanews" id="id1">1</a>.</p>
<div class="section" id="cleaning-data-while-reading">
<h2>Cleaning data while reading<a class="headerlink" href="#cleaning-data-while-reading" title="Permalink to this headline">¶</a></h2>
<p>In this section we are using weather observation data from Finland that was downloaded from NOAA (see <code class="docutils literal notranslate"><span class="pre">Datasets</span></code> chapter for further details). The input data is separated with varying number of spaces (i.e., fixed width). The first lines and columns of the data look like following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">USAF</span>  <span class="n">WBAN</span> <span class="n">YR</span><span class="o">--</span><span class="n">MODAHRMN</span> <span class="n">DIR</span> <span class="n">SPD</span> <span class="n">GUS</span> <span class="n">CLG</span> <span class="n">SKC</span> <span class="n">L</span> <span class="n">M</span> <span class="n">H</span>  <span class="n">VSB</span> <span class="n">MW</span> <span class="n">MW</span> <span class="n">MW</span> <span class="n">MW</span> <span class="n">AW</span>  <span class="o">...</span>
<span class="mi">029440</span> <span class="mi">99999</span> <span class="mi">190601010600</span> <span class="mi">090</span>   <span class="mi">7</span> <span class="o">***</span> <span class="o">***</span> <span class="n">OVC</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span>  <span class="mf">0.0</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span>  <span class="o">...</span>
<span class="mi">029440</span> <span class="mi">99999</span> <span class="mi">190601011300</span> <span class="o">***</span>   <span class="mi">0</span> <span class="o">***</span> <span class="o">***</span> <span class="n">OVC</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span>  <span class="mf">0.0</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span>  <span class="o">...</span>
<span class="mi">029440</span> <span class="mi">99999</span> <span class="mi">190601012000</span> <span class="o">***</span>   <span class="mi">0</span> <span class="o">***</span> <span class="o">***</span> <span class="n">OVC</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span>  <span class="mf">0.0</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span>  <span class="o">...</span>
<span class="mi">029440</span> <span class="mi">99999</span> <span class="mi">190601020600</span> <span class="o">***</span>   <span class="mi">0</span> <span class="o">***</span> <span class="o">***</span> <span class="n">CLR</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span>  <span class="mf">0.0</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span> <span class="o">**</span>  <span class="o">...</span>
</pre></div>
</div>
<p>By looking at the data, we can notice a few things that we need to consider when reading the data:</p>
<ol class="simple">
<li><p><strong>Delimiter:</strong> The columns are separated with a varying amount of spaces which requires using some special tricks when reading the data with pandas <code class="docutils literal notranslate"><span class="pre">read_csv()</span></code> function</p></li>
<li><p><strong>NoData values:</strong> NaN values in the NOAA data are coded with varying number of <code class="docutils literal notranslate"><span class="pre">*</span></code> characters, hence, we need to be able to instruct pandas to interpret those as NaNs.</p></li>
<li><p><strong>Many columns</strong>: The input data contains many columns (altogether 33). Many of those do not contain any meaningful data for our needs. Hence, we should probably ignore the unnecessary columns already at this stage.</p></li>
</ol>
<p>Handling and cleaning heterogeneous input data (such as our example here) could naturally be done after the data has been imported to a DataFrame. However, in many cases, it is actually useful to do some cleaning and preprocessing already when reading the data. In fact, that is often much easier to do. In our case, we can read the data with varying number of spaces between the columns (1) by using a parameter <code class="docutils literal notranslate"><span class="pre">delim_whitespace=True</span></code> (alternatively, specifying <code class="docutils literal notranslate"><span class="pre">sep='\s+'</span></code> would work). For handling the NoData values (2), we can tell pandas to consider the <code class="docutils literal notranslate"><span class="pre">*</span></code> characters as NaNs by using a paramater <code class="docutils literal notranslate"><span class="pre">na_values</span></code> and specifying a list of characters that should be converted to NaNs. Hence, in this case we can specify <code class="docutils literal notranslate"><span class="pre">na_values=['*',</span> <span class="pre">'**',</span> <span class="pre">'***',</span> <span class="pre">'****',</span> <span class="pre">'*****',</span> <span class="pre">'******']</span></code> which will then convert the varying number of <code class="docutils literal notranslate"><span class="pre">*</span></code> characters into NaN values. Finally, we can limit the number of columns that we read (3) by using the <code class="docutils literal notranslate"><span class="pre">usecols</span></code> parameter, which we already used previously. In our case, we are interested in columns that might be somehow useful to our analysis (or at least meaningful to us), including e.g. the station name, timestamp, and data about the wind and temperature: <code class="docutils literal notranslate"><span class="pre">'USAF','YR--MODAHRMN',</span> <span class="pre">'DIR',</span> <span class="pre">'SPD',</span> <span class="pre">'GUS','TEMP',</span> <span class="pre">'MAX',</span> <span class="pre">'MIN'</span></code>. Achieving all these things is pretty straightforward using the <code class="docutils literal notranslate"><span class="pre">read_csv()</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="c1"># Define relative path to the file</span>
<span class="n">fp</span> <span class="o">=</span> <span class="s2">&quot;data/029820.txt&quot;</span>

<span class="c1"># Read data using varying amount of spaces as separator,</span>
<span class="c1"># specifying &#39;*&#39; characters as NoData values,</span>
<span class="c1"># and selecting only specific columns from the data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
    <span class="n">fp</span><span class="p">,</span>
    <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">na_values</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="s2">&quot;***&quot;</span><span class="p">,</span> <span class="s2">&quot;****&quot;</span><span class="p">,</span> <span class="s2">&quot;*****&quot;</span><span class="p">,</span> <span class="s2">&quot;******&quot;</span><span class="p">],</span>
    <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;USAF&quot;</span><span class="p">,</span> <span class="s2">&quot;YR--MODAHRMN&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">,</span> <span class="s2">&quot;SPD&quot;</span><span class="p">,</span> <span class="s2">&quot;GUS&quot;</span><span class="p">,</span> <span class="s2">&quot;TEMP&quot;</span><span class="p">,</span> <span class="s2">&quot;MAX&quot;</span><span class="p">,</span> <span class="s2">&quot;MIN&quot;</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Let’s see now how the data looks by printing the first five rows with the <code class="docutils literal notranslate"><span class="pre">head()</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Perfect, looks good. We have skipped a bunch of unnecessary columns and also the asterisk (*) characters have been correctly converted to NaN values.</p>
</div>
<div class="section" id="renaming-columns">
<h2>Renaming columns<a class="headerlink" href="#renaming-columns" title="Permalink to this headline">¶</a></h2>
<p>Let’s take a closer look at the column names of our DataFrame:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">columns</span>
</pre></div>
</div>
<p>As we see, some of the column names are a bit awkward and difficult to interpret (a description for the columns is available in the metadata <span class="xref myst">data/3505doc.txt</span>). Luckily, it is easy to alter labels in a pandas DataFrame using the <code class="docutils literal notranslate"><span class="pre">rename()</span></code> function. In order to change the column names, we need to tell pandas how we want to rename the columns using a dictionary that converts the old names to new ones. As you probably remember from Chapter 1, a <code class="docutils literal notranslate"><span class="pre">dictionary</span></code> is a specific data structure in Python for storing key-value pairs. We can define the new column names using a dictionary where we list “<code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">value</span></code>” pairs in following manner:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">USAF</span></code>: <code class="docutils literal notranslate"><span class="pre">STATION_NUMBER</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">YR--MODAHRMN</span></code>: <code class="docutils literal notranslate"><span class="pre">TIME</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SPD</span></code>: <code class="docutils literal notranslate"><span class="pre">SPEED</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GUS</span></code>: <code class="docutils literal notranslate"><span class="pre">GUST</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TEMP</span></code>: <code class="docutils literal notranslate"><span class="pre">TEMP_F</span></code></p></li>
</ul>
<p>Hence, the original column name (e.g. <code class="docutils literal notranslate"><span class="pre">YR--MODAHRMN</span></code>) is the dictionary <code class="docutils literal notranslate"><span class="pre">key</span></code> which will be converted to a new column name <code class="docutils literal notranslate"><span class="pre">TIME</span></code> (which is the <code class="docutils literal notranslate"><span class="pre">value</span></code>). The temperature values in our data file is again represented in Fahrenheit. We will soon convert these temperatures to Celsius. Hence, in order to avoid confusion with the columns, let’s rename the column <code class="docutils literal notranslate"><span class="pre">TEMP</span></code> to <code class="docutils literal notranslate"><span class="pre">TEMP_F</span></code>. Also the station number <code class="docutils literal notranslate"><span class="pre">USAF</span></code> is much more intuitive if we call it <code class="docutils literal notranslate"><span class="pre">STATION_NUMBER</span></code>. Let’s create a dictionary for the new column names:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_names</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;USAF&quot;</span><span class="p">:</span> <span class="s2">&quot;STATION_NUMBER&quot;</span><span class="p">,</span>
    <span class="s2">&quot;YR--MODAHRMN&quot;</span><span class="p">:</span> <span class="s2">&quot;TIME&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SPD&quot;</span><span class="p">:</span> <span class="s2">&quot;SPEED&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GUS&quot;</span><span class="p">:</span> <span class="s2">&quot;GUST&quot;</span><span class="p">,</span>
    <span class="s2">&quot;TEMP&quot;</span><span class="p">:</span> <span class="s2">&quot;TEMP_F&quot;</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">new_names</span>
</pre></div>
</div>
<p>Our dictionary looks correct, so now we can change the column names by passing that dictionary using the parameter <code class="docutils literal notranslate"><span class="pre">columns</span></code> in the <code class="docutils literal notranslate"><span class="pre">rename()</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_names</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">columns</span>
</pre></div>
</div>
<p>Perfect, now our column names are easier to understand and use.</p>
</div>
<div class="section" id="using-functions-with-pandas">
<h2>Using functions with pandas<a class="headerlink" href="#using-functions-with-pandas" title="Permalink to this headline">¶</a></h2>
<p>Now it’s time to convert those temperatures from Fahrenheit to Celsius. We have done this many times before, but this time we will learn how to apply our own functions to data in a pandas DataFrame. We will define a function for the temperature conversion, and apply this function for each Celsius value on each row of the DataFrame. Output celsius values should be stored in a new column called <code class="docutils literal notranslate"><span class="pre">TEMP_C</span></code>. But first, it is a good idea to check some basic properties of our new input data before proceeding with data analysis:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># First rows</span>
<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Last rows</span>
<span class="n">data</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Data types</span>
<span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
</pre></div>
</div>
<p>Nothing suspicous for the first and last rows, but here with <code class="docutils literal notranslate"><span class="pre">info()</span></code> we can see that the number of observations per column seem to be varying if you compare the <code class="docutils literal notranslate"><span class="pre">Non-Null</span> <span class="pre">Count</span></code> information to the number of entries in the data (N=198334). Only station number and time seem to have data on each row. All other columns seem to have some missing values. This is not necessarily anything dangerous, but good to keep in mind. Let’s still look at the descriptive statistics:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Descriptive stats</span>
<span class="n">data</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
</pre></div>
</div>
<p>By looking at the <code class="docutils literal notranslate"><span class="pre">TEMP_F</span></code> values (Fahrenheit temperatures), we can confirm that our measurements seems more or less valid because the value range of the temperatures makes sense, i.e. there are no outliers such as extremely high <code class="docutils literal notranslate"><span class="pre">MAX</span></code> values or low <code class="docutils literal notranslate"><span class="pre">MIN</span></code> values. It is always a good practice to critically check your data before doing any analysis, as it is possible that your data may include incorrect values, e.g. due to a sensor malfunction or human error.</p>
<div class="section" id="defining-a-function">
<h3>Defining a function<a class="headerlink" href="#defining-a-function" title="Permalink to this headline">¶</a></h3>
<p>Now we are sure that our data looks okay, and we can start our temperature conversion process by first defining our temperature conversion function from Fahrenheit to Celsius. Pandas can use regular functions, hence you can define functions for pandas exactly in the same way as you would do normally (as we learned in Chapter 1). Hence, let’s define a function that converts Fahrenheits to Celsius:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fahr_to_celsius</span><span class="p">(</span><span class="n">temp_fahrenheit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to convert Fahrenheit temperature into Celsius.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    temp_fahrenheit: int | float</span>
<span class="sd">        Input temperature in Fahrenheit (should be a number)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    Temperature in Celsius (float)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert the Fahrenheit into Celsius</span>
    <span class="n">converted_temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp_fahrenheit</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>

    <span class="k">return</span> <span class="n">converted_temp</span>
</pre></div>
</div>
<p>Now we have the function defined and stored in memory. At this point it is good to test the function with some known value:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fahr_to_celsius</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<p>32 Fahrenheits is indeed 0 Celsius, so our function seem to be working correctly.</p>
</div>
<div class="section" id="using-a-function-by-iterating-over-rows">
<h3>Using a function by iterating over rows<a class="headerlink" href="#using-a-function-by-iterating-over-rows" title="Permalink to this headline">¶</a></h3>
<p>Next we will learn how to use our function with data stored in pandas DataFrame. We will first apply the function row-by-row using a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop and then we will learn a more efficient way of applying the function to all rows at once.</p>
<p>Looping over rows in a DataFrame can be done in a couple of different ways. A common approach is to use a <code class="docutils literal notranslate"><span class="pre">iterrows()</span></code> method which loops over the rows as a index-Series pairs. In other words, we can use the <code class="docutils literal notranslate"><span class="pre">iterrows()</span></code> method together with a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop to repeat a process <em>for each row in a Pandas DataFrame</em>. Please note that iterating over rows this way is a rather inefficient approach, but it is still useful to understand the logic behind the iteration (we will learn a more efficient approach later). When using the <code class="docutils literal notranslate"><span class="pre">iterrows()</span></code> method it is important to understand that <code class="docutils literal notranslate"><span class="pre">iterrows()</span></code> accesses not only the values of one row, but also the <code class="docutils literal notranslate"><span class="pre">index</span></code> of the row as we mentioned. Let’s start with a simple for loop that goes through each row in our DataFrame:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Iterate over the rows</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>

    <span class="c1"># Print the index value</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Index:&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="c1"># Print the temperature from the row</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Temp F:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;TEMP_F&quot;</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">break</span>
</pre></div>
</div>
<p>We can see that the <code class="docutils literal notranslate"><span class="pre">idx</span></code> variable indeed contains the index value at position 0 (the first row) and the <code class="docutils literal notranslate"><span class="pre">row</span></code> variable contains all the data from that given row stored as a pandas <code class="docutils literal notranslate"><span class="pre">Series</span></code>. Notice, that when developing a for loop, you don’t always need to go through the entire loop if you just want to test things out. Using the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement in Python terminates a loop whenever it is placed inside a loop. We used it here just to test check out the values on the first row. With a large data, you might not want to print out thousands of values to the screen!</p>
<p>Let’s now create an empty column <code class="docutils literal notranslate"><span class="pre">TEMP_C</span></code> for the Celsius temperatures and update the values in that column using the <code class="docutils literal notranslate"><span class="pre">fahr_to_celsius()</span></code> function that we defined earlier. For updating the value, we can use <code class="docutils literal notranslate"><span class="pre">at</span></code> which we already used earlier in this chapter. This time, we will use the <code class="docutils literal notranslate"><span class="pre">itertuples()</span></code> method which works in a similar manner, except it only return the row values without the <code class="docutils literal notranslate"><span class="pre">index</span></code>. When using <code class="docutils literal notranslate"><span class="pre">itertuples()</span></code> accessing the row values needs to be done a bit differently, because the row is not a Series, but a <code class="docutils literal notranslate"><span class="pre">named</span> <span class="pre">tuple</span></code> (hence the name). A tuple is like a list (but immutable, i.e. you cannot change it) and “named tuple” is a special kind of tuple object that adds the ability to access the values by name instead of position index. Hence, we will access the <code class="docutils literal notranslate"><span class="pre">TEMP_F</span></code> value by using <code class="docutils literal notranslate"><span class="pre">row.TEMP_F</span></code> (compare to how we accessed the value in the prevous code block):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create an empty column for the output values</span>
<span class="n">data</span><span class="p">[</span><span class="s2">&quot;TEMP_C&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="c1"># Iterate over the rows</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>

    <span class="c1"># Convert the Fahrenheit to Celsius</span>
    <span class="c1"># Notice how we access the row value</span>
    <span class="n">celsius</span> <span class="o">=</span> <span class="n">fahr_to_celsius</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">TEMP_F</span><span class="p">)</span>

    <span class="c1"># Update the value for &#39;Celsius&#39; column with the converted value</span>
    <span class="c1"># Notice how we can access the Index value</span>
    <span class="n">data</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="s2">&quot;TEMP_C&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">celsius</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the result</span>
<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># How does our row look like?</span>
<span class="n">row</span>
</pre></div>
</div>
<p>Okay, now we have iterated over our data and updated the temperatures in Celsius to <code class="docutils literal notranslate"><span class="pre">TEMP_C</span></code> column by using our <code class="docutils literal notranslate"><span class="pre">fahr_to_celsius()</span></code> function. The values look correct as 32 Fahrenheits indeed is 0 Celsius degrees, as can be seen on the second row. We also have here the last row of our DataFrame which is a named tuple. As you can see, it is a bit like a weird looking dictionary with values assigned to the names of our columns. Basically, it is an object with attributes that we can access in a similar manner as we have used to access some of the pandas DataFrame attributes, such as <code class="docutils literal notranslate"><span class="pre">data.shape</span></code>.</p>
<p>A couple of notes about our appoaches. We used <code class="docutils literal notranslate"><span class="pre">itertuples()</span></code> method for looping over the values because it is significantly faster compared to <code class="docutils literal notranslate"><span class="pre">iterrows()</span></code> (can be ~100x faster). We used <code class="docutils literal notranslate"><span class="pre">.at</span></code> to assign the value to the DataFrame because it is designed to access single values more efficiently compared to <code class="docutils literal notranslate"><span class="pre">.loc</span></code>, which can access also groups of rows and columns. That said, you could have used <code class="docutils literal notranslate"><span class="pre">data.loc[idx,</span> <span class="pre">new_column]</span> <span class="pre">=</span> <span class="pre">celsius</span></code> to achieve the same result (it is just slower).</p>
</div>
<div class="section" id="using-a-function-with-apply">
<h3>Using a function with apply<a class="headerlink" href="#using-a-function-with-apply" title="Permalink to this headline">¶</a></h3>
<p>Although using for loop with <code class="docutils literal notranslate"><span class="pre">itertuples()</span></code> can be fairly efficient, pandas DataFrames and Series have a dedicated method called <code class="docutils literal notranslate"><span class="pre">apply()</span></code> for applying functions on columns (or rows). <code class="docutils literal notranslate"><span class="pre">apply()</span></code> is typically faster than <code class="docutils literal notranslate"><span class="pre">itertuples()</span></code>, especially if you have large number of rows, such as in our case. When using <code class="docutils literal notranslate"><span class="pre">apply()</span></code>, we pass the function that we want to use as an argument. Let’s start by applying the function to the <code class="docutils literal notranslate"><span class="pre">TEMP_F</span></code> column that contains the temperature values in Fahrenheit:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;TEMP_F&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">fahr_to_celsius</span><span class="p">)</span>
</pre></div>
</div>
<p>The results look logical. Notice how we passed the <code class="docutils literal notranslate"><span class="pre">fahr_to_celsius()</span></code> function without using the parentheses <code class="docutils literal notranslate"><span class="pre">()</span></code> after the name of the function. When using <code class="docutils literal notranslate"><span class="pre">apply</span></code>, you should always leave out the parentheses from the function that you use. Meaning that you should use <code class="docutils literal notranslate"><span class="pre">apply(fahr_to_celsius)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">apply(fahr_to_celsius())</span></code>. Why? Because the <code class="docutils literal notranslate"><span class="pre">apply()</span></code> method will execute and use the function itself in the background when it operates with the data. If we would pass our function with the parentheses, the <code class="docutils literal notranslate"><span class="pre">fahr_to_celsius()</span></code> function would actually be executed once before the loop with <code class="docutils literal notranslate"><span class="pre">apply()</span></code> starts (hence becoming unusable), and that is not what we want. Our previous command only returned the Series of temperatures to the screen, but naturally we can also store them permanently into a new column (overwriting the old values):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;TEMP_C&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;TEMP_F&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">fahr_to_celsius</span><span class="p">)</span>
</pre></div>
</div>
<p>A nice thing with <code class="docutils literal notranslate"><span class="pre">apply()</span></code> is that we can also apply the function on several columns at once. Below, we also sort the values in descending order based on values in <code class="docutils literal notranslate"><span class="pre">MIN</span></code> column to see that applying our function really works:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;TEMP_F&quot;</span><span class="p">,</span> <span class="s2">&quot;MIN&quot;</span><span class="p">,</span> <span class="s2">&quot;MAX&quot;</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">fahr_to_celsius</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;MIN&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>You can also directly store the outputs to new columns <code class="docutils literal notranslate"><span class="pre">'TEMP_C'</span></code>, <code class="docutils literal notranslate"><span class="pre">'MIN_C'</span></code>, <code class="docutils literal notranslate"><span class="pre">'MAX_C'</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;TEMP_F&quot;</span><span class="p">,</span> <span class="s2">&quot;MIN&quot;</span><span class="p">,</span> <span class="s2">&quot;MAX&quot;</span><span class="p">]</span>
<span class="n">data</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">fahr_to_celsius</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>In this section, we showed you a few different ways to iterate over rows in pandas and apply functions. The most important thing is that you understand the logic of how loops work and how you can use your own functions to modify the values in a pandas DataFrame. Whenever you need to loop over your data, we recommend using <code class="docutils literal notranslate"><span class="pre">.apply()</span></code> as it is typically the most efficient one in terms of execution time. However, remember that in most cases you do not actually need to use loops, but you can do calculations in a “vectorized manner” (which is the fastest way) as we learned previously when doing basic calculations in pandas.</p>
</div>
</div>
<div class="section" id="string-slicing">
<h2>String slicing<a class="headerlink" href="#string-slicing" title="Permalink to this headline">¶</a></h2>
<p>We will eventually want to group our data based on month in order to see if the January temperatures in 2020 were higher than on average (which is the goal in our analysis as you might recall). Currently, the date and time information is stored in the column <code class="docutils literal notranslate"><span class="pre">TIME</span></code> that has a structure <code class="docutils literal notranslate"><span class="pre">yyyyMMddhhmm</span></code>. This is a typical timestamp format in which <code class="docutils literal notranslate"><span class="pre">yyyy</span></code> equals to year in four digit format, <code class="docutils literal notranslate"><span class="pre">MM</span></code> to month (two digits), <code class="docutils literal notranslate"><span class="pre">dd</span></code> days, <code class="docutils literal notranslate"><span class="pre">hh</span></code> hours and <code class="docutils literal notranslate"><span class="pre">mm</span></code> minutes. Let’s have a closer look at the date and time information we have by checking the values in that column, and their data type:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;TIME&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;TIME&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tail</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">TIME</span></code> column contains several observations per day (and even several observations per hour). The timestamp for the first observation is <code class="docutils literal notranslate"><span class="pre">190601010600</span></code>, i.e. from 1st of January 1906 (way back!), and the timestamp for the latest observation is <code class="docutils literal notranslate"><span class="pre">201910012350</span></code>. (<strong>TODO: UPDATE THESE WITH NEW DATA</strong>). As we can see, the data type (<code class="docutils literal notranslate"><span class="pre">dtype</span></code>) of our column seems to be <code class="docutils literal notranslate"><span class="pre">int64</span></code>, i.e. the information is stored as integer values.</p>
<p>We want to aggregate this data on a monthly level. In order to do so, we need to “label” each row of data based on the month when the record was observed. Hence, we need to somehow separate information about the year and month for each row. In practice, we can create a new column (or an index) containing information about the month (including the year, but excluding days, hours and minutes). There are different ways of achieving this, but here we will take advantage of <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">slicing</span></code> which means that we convert the date and time information into character strings and “cut” the needed information from the string objects. The other option would be to convert the timestamp values into something called <code class="docutils literal notranslate"><span class="pre">datetime</span></code> objects, but we will learn about those a bit later. Before further processing, we first want to convert the <code class="docutils literal notranslate"><span class="pre">TIME</span></code> column as character strings for convenience, stored into a new column <code class="docutils literal notranslate"><span class="pre">TIME_STR</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;TIME_STR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;TIME&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<p>If we look at the latest time stamp in the data (<code class="docutils literal notranslate"><span class="pre">201910012350</span></code>) (<strong>UPDATE!</strong>), you can see that there is a systematic pattern <code class="docutils literal notranslate"><span class="pre">YEAR-MONTH-DAY-HOUR-MINUTE</span></code>. Four first characters represent the year, and the following two characters represent month. Because we are interested in understanding monthly averages for different years, we want to slice the year and month values from the timestamp (the first 6 characters), like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">date</span> <span class="o">=</span> <span class="s2">&quot;201910012350&quot;</span>
<span class="n">date</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>Based on this information, we can slice the correct range of characters from the <code class="docutils literal notranslate"><span class="pre">TIME_STR</span></code> column using a specific pandas function designed for Series, called <code class="docutils literal notranslate"><span class="pre">.str.slice()</span></code>. As parameters, the function has <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> which you can use to specify the positions where the slicing should start and end:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;YEAR_MONTH&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;TIME_STR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Nice! Now we have “labeled” the rows based on information about day of the year and hour of the day.</p>
<p><em><strong>Check your understanding (online)</strong></em></p>
<p>By using the interactive online version of this book, create a new column <code class="docutils literal notranslate"><span class="pre">'MONTH'</span></code> with information about the month without the year.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add your solution here</span>
</pre></div>
</div>
</div>
<div class="section" id="grouping-and-aggregating-data">
<h2>Grouping and aggregating data<a class="headerlink" href="#grouping-and-aggregating-data" title="Permalink to this headline">¶</a></h2>
<p>Next, we want to calculate the average temperature for each month in our dataset. Here, we will learn how to use a <code class="docutils literal notranslate"><span class="pre">.groupby()</span></code> method which is a handy tool for compressing large amounts of data and computing statistics for subgroups.</p>
<p>We will use the groupby method to calculate the average temperatures for each month trough these three main steps:</p>
<ol class="simple">
<li><p>group the data based on year and month using <code class="docutils literal notranslate"><span class="pre">groupby()</span></code></p></li>
<li><p>calculate the average for each month (i.e. each group)</p></li>
<li><p>Store those values into a new DataFrame called <code class="docutils literal notranslate"><span class="pre">monthly_data</span></code></p></li>
</ol>
<p>We have quite a few rows of weather data (N=198334) (<strong>UPDATE</strong>), and several observations per day. Our goal is to create an aggreated DataFrame that would have only one row per month. The <code class="docutils literal notranslate"><span class="pre">groupby()</span></code> takes as a parameter the name of the column (or a list of columns) that you want to use as basis for doing the grouping.  Let’s start by grouping our data based on unique year and month combination:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">grouped</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;YEAR_MONTH&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice, thas it would also be possible to create combinations of years and months “on-the-fly” if you have them in separate columns. In such case, grouping the data could be done as <code class="docutils literal notranslate"><span class="pre">grouped</span> <span class="pre">=</span> <span class="pre">data.groupby(['YEAR',</span> <span class="pre">'MONTH'])</span></code>. Let’s explore the new variable <code class="docutils literal notranslate"><span class="pre">grouped</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">grouped</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">))</span>
</pre></div>
</div>
<p>We have a new object with type <code class="docutils literal notranslate"><span class="pre">DataFrameGroupBy</span></code> with 826 groups (<strong>UPDATE</strong>). In order to understand what just happened, let’s also check the number of unique year and month combinations in our data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;YEAR_MONTH&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>
</pre></div>
</div>
<p>Length of the grouped object should be the same as the number of unique values in the column we used for grouping (<code class="docutils literal notranslate"><span class="pre">YEAR_MONTH</span></code>). For each unique value, there is a group of data. Let’s explore our grouped data further by check the “names” of the groups (five first ones). Here, we access the <code class="docutils literal notranslate"><span class="pre">keys</span></code> of the groups and convert them to a <code class="docutils literal notranslate"><span class="pre">list</span></code> so that we can slice and print only a few of those to the sceen:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="n">grouped</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>Let’s check the contents for a group representing January 1906. We can get the values for that month from the grouped object using the <code class="docutils literal notranslate"><span class="pre">get_group()</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specify a month (as character string)</span>
<span class="n">month</span> <span class="o">=</span> <span class="s2">&quot;190601&quot;</span>

<span class="c1"># Select the group</span>
<span class="n">group1</span> <span class="o">=</span> <span class="n">grouped</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">month</span><span class="p">)</span>
<span class="n">group1</span>
</pre></div>
</div>
<p>Aha! As we can see, a single group contains a DataFrame with values only for that specific month. Let’s check the DataType of this group:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">group1</span><span class="p">)</span>
</pre></div>
</div>
<p>So, one group is a pandas DataFrame which is really useful, because it allows us to use all the familiar DataFrame methods for calculating statistics etc. for this specific group. We can, for example, calculate the average values for all variables using the statistical functions that we have seen already (e.g. mean, std, min, max, median). To calculate the average temperature for each month, we can use the <code class="docutils literal notranslate"><span class="pre">mean()</span></code> function. Let’s calculate the mean for all the weather related data attributes in our group at once:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specify the columns that will be part of the calculation</span>
<span class="n">mean_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DIR&quot;</span><span class="p">,</span> <span class="s2">&quot;SPEED&quot;</span><span class="p">,</span> <span class="s2">&quot;GUST&quot;</span><span class="p">,</span> <span class="s2">&quot;TEMP_F&quot;</span><span class="p">,</span> <span class="s2">&quot;TEMP_C&quot;</span><span class="p">]</span>

<span class="c1"># Calculate the mean values all at one go</span>
<span class="n">mean_values</span> <span class="o">=</span> <span class="n">group1</span><span class="p">[</span><span class="n">mean_cols</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">mean_values</span>
</pre></div>
</div>
<p>Here, we aggregated the data into monthly average based on a single group. For aggregating the data for all groups (i.e. all months), we can use a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop or methods available in the grouped object.</p>
<p>It is possible to iterate over the groups in our <code class="docutils literal notranslate"><span class="pre">DataFrameGroupBy</span></code> object. When doing so, it is important to understand that a single group in our <code class="docutils literal notranslate"><span class="pre">DataFrameGroupBy</span></code> actually contains not only the actual values, but also information about the <code class="docutils literal notranslate"><span class="pre">key</span></code> that was used to do the grouping. Hence, when iterating we need to assign the <code class="docutils literal notranslate"><span class="pre">key</span></code> and the values (i.e. the group) into separate variables. Let’s see how we can iterate over the groups and print the key and the data from a single group (again using <code class="docutils literal notranslate"><span class="pre">break</span></code> to only see what is happening):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Iterate over groups</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>
    <span class="c1"># Print key and group</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Key:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">First rows of data in this group:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">group</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>

    <span class="c1"># Stop iteration with break command</span>
    <span class="k">break</span>
</pre></div>
</div>
<p>From here we can see that the <code class="docutils literal notranslate"><span class="pre">key</span></code> contains the name of the group (i.e. the unique value from <code class="docutils literal notranslate"><span class="pre">YEAR_MONTH</span></code>). Let’s now create a new DataFrame which we will use to store and calculate the mean values for all those weather attributes that we were interested in. We will repeat slightly the earlier steps so that you can see and better understand what is happening:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create an empty DataFrame for the aggregated values</span>
<span class="n">monthly_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

<span class="c1"># The columns that we want to aggregate</span>
<span class="n">mean_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DIR&quot;</span><span class="p">,</span> <span class="s2">&quot;SPEED&quot;</span><span class="p">,</span> <span class="s2">&quot;GUST&quot;</span><span class="p">,</span> <span class="s2">&quot;TEMP_F&quot;</span><span class="p">,</span> <span class="s2">&quot;TEMP_C&quot;</span><span class="p">]</span>

<span class="c1"># Iterate over the groups</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>

    <span class="c1"># Calculate mean</span>
    <span class="n">mean_values</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">mean_cols</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="c1"># Add the ´key´ (i.e. the date+time information) into the aggregated values</span>
    <span class="n">mean_values</span><span class="p">[</span><span class="s2">&quot;YEAR_MONTH&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

    <span class="c1"># Append the aggregated values into the DataFrame</span>
    <span class="n">monthly_data</span> <span class="o">=</span> <span class="n">monthly_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_values</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s see what we have now:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">monthly_data</span>
</pre></div>
</div>
<p>Awesome! As a result, we have now aggregated our data and filled the new DataFrame <code class="docutils literal notranslate"><span class="pre">monthly_data</span></code> with mean values for each month in the data set. Alternatively, we can also achieve the same result by <code class="docutils literal notranslate"><span class="pre">chaining</span></code> the <code class="docutils literal notranslate"><span class="pre">groupby()</span></code> function with the aggregation step (such as taking the mean, median etc.). This can be a bit harder to understand, but this is how you could shorten the whole grouping, loop and aggregation process into a single command:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mean_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DIR&quot;</span><span class="p">,</span> <span class="s2">&quot;SPEED&quot;</span><span class="p">,</span> <span class="s2">&quot;GUST&quot;</span><span class="p">,</span> <span class="s2">&quot;TEMP_F&quot;</span><span class="p">,</span> <span class="s2">&quot;TEMP_C&quot;</span><span class="p">]</span>
<span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;YEAR_MONTH&quot;</span><span class="p">)[</span><span class="n">mean_cols</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
</pre></div>
</div>
<p>As we can see, doing the aggregation without a loop requires much less code, and in fact, it is also faster. So what did we do here? We 1) grouped the data, 2) selected specific columns from the result (<code class="docutils literal notranslate"><span class="pre">mean_cols</span></code>), 3) calculated the mean for all of the selected columns, and finally 4) reset the index. Resetting the index at the end is not necessary, but by doing it, we turn the <code class="docutils literal notranslate"><span class="pre">YEAR_MONTH</span></code> values (that would be otherwise store in <code class="docutils literal notranslate"><span class="pre">index</span></code>) into a dedicated column in our data.</p>
<p>So which approach should you use? From the performance point of view, we recommend using the latter approach (i.e. chaining) which does not require a loop and is highly performant. However, this approach might be a bit difficult to read and comprehend (the loop might be easier), and sometimes you want to include additional processing steps inside the loop which can be hard accomplish by chaining everything into a single command. Hence, it is useful to know both of these approaches for doing aggregations with the data.</p>
</div>
<div class="section" id="case-study-detecting-warm-months">
<h2>Case study: Detecting warm months<a class="headerlink" href="#case-study-detecting-warm-months" title="Permalink to this headline">¶</a></h2>
<p>Now, we have aggregated our data on monthly level and all we need to do is to check which years had the warmest January temperatures. A simple approach is to select all January values from the data and check which group(s) have the highest mean value. Before doing this, let’s separate the month information from our timestamp following the same approach as previously we did when slicing the year-month combination:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">monthly_data</span><span class="p">[</span><span class="s2">&quot;MONTH&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">monthly_data</span><span class="p">[</span><span class="s2">&quot;YEAR_MONTH&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">monthly_data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we can select the values for January from our data and store it into a new variable <code class="docutils literal notranslate"><span class="pre">january_data</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">january_data</span> <span class="o">=</span> <span class="n">monthly_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">monthly_data</span><span class="p">[</span><span class="s2">&quot;MONTH&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;01&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Now, we can check the highest temperature values by sorting the DataFrame in a descending order:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">january_data</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;TEMP_C&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Now by looking at the order of <code class="docutils literal notranslate"><span class="pre">YEAR_MONTH</span></code> column, we can see that January 2020 indeed was on average the warmest month on record based on weather observations from Finland. (<strong>UPDATE</strong>)</p>
</div>
<div class="section" id="automating-the-analysis">
<h2>Automating the analysis<a class="headerlink" href="#automating-the-analysis" title="Permalink to this headline">¶</a></h2>
<p>Now we have learned how to aggregate data using pandas. average temperatures for each month based on hourly weather observations. One of the most useful aspects of programming, is the ability to automate processes and repeat analyses such as these for any number of weather stations (assuming the data structure is the same).</p>
<p>Hence, let’s now see how we can repeat the previous data analysis steps for all the available data we have from 15 weather stations located in different parts of Finland. The idea is that we will repeat the process for each input file using a (rather long) for loop. We will use the most efficient alternatives of the previously represented approaches, and finally will store the results in a single DataFrame for all stations. We will use the <code class="docutils literal notranslate"><span class="pre">glob()</span></code> function from the Python module <code class="docutils literal notranslate"><span class="pre">glob</span></code> to list our input files in the data directory <code class="docutils literal notranslate"><span class="pre">data</span></code>. We will store those paths to a variable <code class="docutils literal notranslate"><span class="pre">file_list</span></code>, so that we can use the file paths easily in the later steps:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>

<span class="n">file_list</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="s2">&quot;data/0*txt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we’re using the * character as a wildcard, so any file that starts with <code class="docutils literal notranslate"><span class="pre">data/0</span></code> and ends with <code class="docutils literal notranslate"><span class="pre">txt</span></code> will be added to the list of files. We specifically use <code class="docutils literal notranslate"><span class="pre">data/0</span></code> as the starting part of the file names to avoid having our metadata files included in the list.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of files in the list:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">))</span>
<span class="n">file_list</span>
</pre></div>
</div>
<p>Now, you should have all the relevant file paths in the <code class="docutils literal notranslate"><span class="pre">file_list</span></code>, and we can loop over the list using a for loop (again we break the loop after first iteration):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">fp</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
    <span class="k">break</span>
</pre></div>
</div>
<p>Now we have all the file paths to our weather observation datasets in a list, and we can start iterating over them and repeat the analysis steps for each file separately. We keep all the analytical steps inside a loop so that all of them are repeated to different stations. Finally, we will store the warmest January for each station in a new DataFrame called <code class="docutils literal notranslate"><span class="pre">results</span></code> using an <code class="docutils literal notranslate"><span class="pre">append()</span></code> method which works quite in a similar manner as appending values to a regular list:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># DataFrame for the end results</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

<span class="c1"># Repeat the analysis steps for each input file:</span>
<span class="k">for</span> <span class="n">fp</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>

    <span class="c1"># Read selected columns of  data using varying amount of spaces as separator and specifying * characters as NoData values</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
        <span class="n">fp</span><span class="p">,</span>
        <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;USAF&quot;</span><span class="p">,</span> <span class="s2">&quot;YR--MODAHRMN&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">,</span> <span class="s2">&quot;SPD&quot;</span><span class="p">,</span> <span class="s2">&quot;GUS&quot;</span><span class="p">,</span> <span class="s2">&quot;TEMP&quot;</span><span class="p">,</span> <span class="s2">&quot;MAX&quot;</span><span class="p">,</span> <span class="s2">&quot;MIN&quot;</span><span class="p">],</span>
        <span class="n">na_values</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="s2">&quot;***&quot;</span><span class="p">,</span> <span class="s2">&quot;****&quot;</span><span class="p">,</span> <span class="s2">&quot;*****&quot;</span><span class="p">,</span> <span class="s2">&quot;******&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Rename the columns</span>
    <span class="n">new_names</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;USAF&quot;</span><span class="p">:</span> <span class="s2">&quot;STATION_NUMBER&quot;</span><span class="p">,</span>
        <span class="s2">&quot;YR--MODAHRMN&quot;</span><span class="p">:</span> <span class="s2">&quot;TIME&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SPD&quot;</span><span class="p">:</span> <span class="s2">&quot;SPEED&quot;</span><span class="p">,</span>
        <span class="s2">&quot;GUS&quot;</span><span class="p">:</span> <span class="s2">&quot;GUST&quot;</span><span class="p">,</span>
        <span class="s2">&quot;TEMP&quot;</span><span class="p">:</span> <span class="s2">&quot;TEMP_F&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_names</span><span class="p">)</span>

    <span class="c1"># Print info about the current input file (useful to understand how the process advances):</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;STATION NUMBER: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;STATION_NUMBER&#39;</span><span class="p">]</span><span class="si">}</span><span class="se">\t</span><span class="s2">NUMBER OF OBSERVATIONS: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Create column</span>
    <span class="n">col_name</span> <span class="o">=</span> <span class="s2">&quot;TEMP_C&quot;</span>
    <span class="n">data</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Convert tempetarues from Fahrenheits to Celsius</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;TEMP_C&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;TEMP_F&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">fahr_to_celsius</span><span class="p">)</span>

    <span class="c1"># Convert TIME to string</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;TIME_STR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;TIME&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

    <span class="c1"># Parse year and month and convert them to numbers</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;MONTH&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;TIME_STR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;YEAR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;TIME_STR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Extract observations for the months of January</span>
    <span class="n">january</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MONTH&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Aggregate the data and get mean values</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;TEMP_F&quot;</span><span class="p">,</span> <span class="s2">&quot;TEMP_C&quot;</span><span class="p">,</span> <span class="s2">&quot;STATION_NUMBER&quot;</span><span class="p">]</span>
    <span class="n">monthly_mean</span> <span class="o">=</span> <span class="n">january</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="s2">&quot;MONTH&quot;</span><span class="p">])[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="c1"># Sort the values and take the warmest January</span>
    <span class="n">warmest</span> <span class="o">=</span> <span class="n">monthly_mean</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;TEMP_C&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Add to results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warmest</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Awesome! Now we have conducted the same analysis for 15 weather stations in Finland and it did not took too many lines of code! We were able to follow how the process advances with the printed lines of information, i.e. we did some simple <code class="docutils literal notranslate"><span class="pre">logging</span></code> of the operations. Notice that when using the <code class="docutils literal notranslate"><span class="pre">append()</span></code> function, we used <code class="docutils literal notranslate"><span class="pre">ignore_index=True</span></code> which means that the original index value of the row in <code class="docutils literal notranslate"><span class="pre">warmest</span></code> DataFrame is not kept when storing the row to the <code class="docutils literal notranslate"><span class="pre">results</span></code> DataFrame (which might cause conflicts if two rows would happen to have identical index labels). Let’s finally investigate our results:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">results</span>
</pre></div>
</div>
<p>Each row in the results represents the warmest January at given <code class="docutils literal notranslate"><span class="pre">STATION_NUMBER</span></code> throughout the recorded years (1906 onwards). Based on the <code class="docutils literal notranslate"><span class="pre">YEAR</span></code> column, the warmest January in most of Finland’s weather stations has been during the past 15 years. We can confirm this by checking the value counts of the <code class="docutils literal notranslate"><span class="pre">YEAR</span></code> column:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;YEAR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>
</div>
<p>As we can see, the January in 2005 was exceptionally warm in most of Finland. (<strong>UPDATE</strong>)</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<p>In this Exercise, we will explore our temperature data by comparing spring temperatures between Kumpula and Rovaniemi. To do this we’ll use some conditions to extract subsets of our data and then analyse these subsets using basic pandas functions. Notice that in this exercise, we will use data saved from the previous Exercise (2.2.6), hence you should finish that Exercise before this one. An overview of the tasks in this exercise:</p>
<ul class="simple">
<li><p>Calculate the median temperatures for Kumpula and Rovaniemi for the summer of 2017</p></li>
<li><p>Select temperatures for May and June 2017 in separate DataFrames for each location</p></li>
<li><p>Calculate descriptive statistics for each month (May, June) and location (Kumpula, Rovaniemi)</p></li>
</ul>
<div class="section" id="problem-1-read-the-data-and-calculate-basic-statistics">
<h3>Problem 1 - Read the data and calculate basic statistics<a class="headerlink" href="#problem-1-read-the-data-and-calculate-basic-statistics" title="Permalink to this headline">¶</a></h3>
<p>Read in the CSV files generated in Exercise 2.2.6 to the variables <code class="docutils literal notranslate"><span class="pre">kumpula</span></code> and <code class="docutils literal notranslate"><span class="pre">rovaniemi</span></code> and answer to following questions:</p>
<ul class="simple">
<li><p>What was the median Celsius temperature during the observed period in Helsinki Kumpula? Store the answer in a variable <code class="docutils literal notranslate"><span class="pre">kumpula_median</span></code>.</p></li>
<li><p>What was the median Celsius temperature during the observed period in Rovaniemi? Store the answer in a variable <code class="docutils literal notranslate"><span class="pre">rovaniemi_median</span></code>.</p></li>
</ul>
<!-- #region -->
</div>
<div class="section" id="problem-2-select-data-and-compare-temperatures-between-months">
<h3>Problem 2 - Select data and compare temperatures between months<a class="headerlink" href="#problem-2-select-data-and-compare-temperatures-between-months" title="Permalink to this headline">¶</a></h3>
<p>The median temperatures above consider data from the entire summer (May-Aug), hence the differences might not be so clear. Let’s now find out the mean temperatures from May and June 2017 in Kumpula and Rovaniemi:</p>
<ul class="simple">
<li><p>From the <code class="docutils literal notranslate"><span class="pre">kumpula</span></code> and <code class="docutils literal notranslate"><span class="pre">rovaniemi</span></code> DataFrames, select the rows where values of the <code class="docutils literal notranslate"><span class="pre">YR--MODAHRMN</span></code> column are from May 2017. Assign these selected rows into the variables <code class="docutils literal notranslate"><span class="pre">kumpula_may</span></code> and <code class="docutils literal notranslate"><span class="pre">rovaniemi_may</span></code></p></li>
<li><p>Repeat the procedure for the month of June and assign those values into variables to <code class="docutils literal notranslate"><span class="pre">kumpula_june</span></code> and <code class="docutils literal notranslate"><span class="pre">rovaniemi_june</span></code></p></li>
<li><p>Calculate and print the mean, min and max Celsius temperatures for both places in May and June using the new subset dataframes (kumpula_may, rovaniemi_may, kumpula_june, and rovaniemi_june). Answer to following questions:</p>
<ul>
<li><p>Does there seem to be a large difference in temperatures between the months?</p></li>
<li><p>Is Rovaniemi a much colder place than Kumpula?</p></li>
</ul>
</li>
</ul>
<!-- #endregion -->
</div>
<div class="section" id="problem-3-parse-daily-temperatures-by-aggregating-data">
<h3>Problem 3 - Parse daily temperatures by aggregating data<a class="headerlink" href="#problem-3-parse-daily-temperatures-by-aggregating-data" title="Permalink to this headline">¶</a></h3>
<p>In this problem, the aim is to aggregate the hourly temperature data for Kumpula and Rovaniemi weather stations to a daily level. Currently, there are at most three measurements per hour in the data, as you can see from the YR–MODAHRMN column:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">USAF</span>  <span class="n">YR</span><span class="o">--</span><span class="n">MODAHRMN</span>  <span class="n">TEMP</span>  <span class="n">MAX</span>  <span class="n">MIN</span>  <span class="n">Celsius</span>
<span class="mi">0</span>  <span class="mi">28450</span>  <span class="mi">201705010000</span>  <span class="mf">31.0</span>  <span class="n">NaN</span>  <span class="n">NaN</span>       <span class="o">-</span><span class="mi">1</span>
<span class="mi">1</span>  <span class="mi">28450</span>  <span class="mi">201705010020</span>  <span class="mf">30.0</span>  <span class="n">NaN</span>  <span class="n">NaN</span>       <span class="o">-</span><span class="mi">1</span>
<span class="mi">2</span>  <span class="mi">28450</span>  <span class="mi">201705010050</span>  <span class="mf">30.0</span>  <span class="n">NaN</span>  <span class="n">NaN</span>       <span class="o">-</span><span class="mi">1</span>
<span class="mi">3</span>  <span class="mi">28450</span>  <span class="mi">201705010100</span>  <span class="mf">31.0</span>  <span class="n">NaN</span>  <span class="n">NaN</span>       <span class="o">-</span><span class="mi">1</span>
<span class="mi">4</span>  <span class="mi">28450</span>  <span class="mi">201705010120</span>  <span class="mf">30.0</span>  <span class="n">NaN</span>  <span class="n">NaN</span>       <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>In this exercise you should:</p>
<ul class="simple">
<li><p>Summarize the information for each day by aggregating (grouping) the DataFrame using the <code class="docutils literal notranslate"><span class="pre">groupby()</span></code> function.</p></li>
<li><p>The output should be a new DataFrame where you have calculated mean, max and min Celsius temperatures for each day separately based on hourly values.</p></li>
<li><p>Repeat the task for the two data sets you created in Problem 2 (May-August temperatures from Rovaniemi and Kumpula).</p></li>
</ul>
</div>
</div>
<div class="section" id="footnotes">
<h2>Footnotes<a class="headerlink" href="#footnotes" title="Permalink to this headline">¶</a></h2>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="noaanews"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><a class="reference external" href="https://www.noaa.gov/news/january-2020-was-earth-s-hottest-january-on-record">https://www.noaa.gov/news/january-2020-was-earth-s-hottest-january-on-record</a></p>
</dd>
</dl>
</div>
</div>


              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp<br/>
    
        &copy; Copyright 2020, Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>